## Power of using a single structured 'Project' directory for storing and tracking research project files

To improve the computational reproducibility of a research project, researchers
can use a single 'Project' directory to collectively store all research data,
meta-data, pre-processing code, and research products (e.g., paper drafts,
figures). We will explain how this practice improves the reproducibility and
list some of the common components and subdirectories to include in the
structure of a 'Project' directory, including subdirectories for raw and
pre-processed experimental data.

**Objectives.** After this module, the trainee will be able to:

- Describe a 'Project' directory, including common components and subdirectories 
- List how a single 'Project' directory improves reproducibility

### Organizing project files through the file system

One of the most amazing parts of how modern computers work is their file 
directory systems. [More on these.]

It is useful to leverage this system to organize all the files related to a 
project. These include data files (both "raw" data---directly output from 
measurement equipment or directly recorded from observations, as well as any 
"cleaned" version of this data, after steps have been taken to preprocess the
data to prepare it for visualization and analysis in papers and reports). These
files also include the files with writing and presentations (posters and slides)
associated with the project, as well as code scripts for preprocessing data,
for conducting data analysis, and for creating and sharing final figures and 
tables. 

There are a number of advantages to keeping all files related to a single project
inside a dedicated file directory on your computer. First, this provides a clear
and obvious place to search for all project files throughout your work on the 
project, including after lulls in activity (for example, while waiting for 
reviews from a paper submission). By keeping all project files within a single
directory, you also make it easier to share the collection of files for the 
project. There are several reasons you might want to share these files. An 
obvious one is that you likely will want to share the project files across members
in your research team, so they can collaborate together on the project. However, 
there are also other reasons you'd need to share files, and one that is growing 
in popularity is that you may be asked to share files (data, code scripts, etc.)
when you publish a paper describing your results. 

When files are all stored in one directory, the directory can be compressed and 
shared as an email attachment or through a file sharing platform like Google Drive. 
As you learn more tools for reproducibility, you can also share the directory through
some more dynamic platforms, that let all those sharing access continue to change 
and contribute to the files in the directory in a way that is tracked and 
reversible. In later modules in this book, we will introduce `git` version control 
software and the GitHub platform for sharing files under this type of version 
control---this is one example of this more dynamic way of sharing files within 
a directory. 

### Organizing files within a project directory

To gain the advantages of directory-based project file organization, all the
files need to be within a single directory, but they don't all have to be within
the same "level" in that directory. Instead, you can use subdirectories to
structure and organize these files, while still retaining all the advantages of
directory-based file organization. This will help limit the number of files in
each "level" of the directory, so none becomes an overwhelming slew of files of
different types. It can help you navigate the files in the directory, and also
help someone you share the directory with figure out what's in it and where
everything is. 

Subdirectory organizations can also, it turns out, be used in clever ways within
code scripts applied to files in the directory. For example, there are functions
in all scripting languages that will list all the files in a specified subdirectory.
If you keep all your raw data files of a certain type (for example, all output from 
running flow cytometry for the project) within a single subdirectory, you can 
use this type of function with code scripts to list all the files in that directory 
and then apply code that you've developed to preprocess or visualize the data
across all those files. This code would continue to work as you added files to that
directory, since it starts by looking in that subdirectory each time it runs and 
working with all files there as of that moment.

It is worthwhile to take some time to think about the types of files that are 
often generated by your research projects, because there are also big advantages
to creating a standard structure of subdirectories that you can use consistently 
across the directories for all the projects in your research program. Of course, 
some projects may not include certain files, and some might have a new or unusual
type of file, so you can customize the directory structure to some degree for these
types of cases, but it is still a big advantage to include as many common elements
as possible across all your projects. 

For example, you may want to always include a subdirectory called "raw_data", and
consistently call it "raw_data", to store data directly from observations or 
directly output from laboratory equipment. You may want to include subdirectories
in that "raw_data" subdirectory for each type of data---maybe a "cfu" subdirectory, 
for example, with results from plating data to count colony forming units, and 
another called "flow" for output from a flow cytometer. By using the same structure
and the same subdirectory names, you will find that code scripts are easier to 
reuse from one project to another. Again, most scripting languages allow you to
leverage order in how you've arranged your files in the file system, and so using
the same order across different projects lets you repeat and reuse code scripts
more easily from one project to another. 

Finally, if you create a clear and clean organization structure for your project
directories, you will find it is much easier to navigate your files in all
directories, and also that new lab members and others you share the directories
with will be able to quickly learn to navigate them. In other areas of science
and engineering, this idea of standardized directory structures has allowed the
development of powerful techniques for open-source software developers to work
together. For example, anyone may create their own extensions to the R
programming language and share these with others through GitHub or several large
repositories. This is coordinated by enforcing a common directory structure on
these extension "packages"---to create a new package, you must put certain types
of files in certain subdirectories within a project directory. With these
standardized rules of directory structure and content, each of these packages
can interact with the base version of R, since there are functions that can tap
into any of these new packages by assuming where each type of file will be
within the package's directory of files. In a similar way, if you impose a
common directory structure across all the project directories in your research
lab, your collaborators will quickly be able to learn where to find each
element, even in projects they are new to, and you will all be able to write
code that can be easily applied across all project directories, allowing you to
improve reproducibility and comparability across all projects by assuring that
you are conducting the same preprocessing and analysis across all projects (or,
if you are conducting things differently for different projects, that you are
deliberate and aware that you are doing so).

Figure [x] gives an example of a project directory organization that might make
sense for a immunology research laboratory. 

Once you have decided on a structure for your directory, you can create a 
template of it---a file directory with all the subdirectories included, but
without any files (or only template files you'd want to use as a starting
point in each project). When you start a new project, you can then just
copy this template and rename it. If you are using R and begin to use
R Project (described in the next section), you can also create an R Studio
Project template to serve as this kind of starting point each time you 
start a new project. 

### Using RStudio Projects with project file directories

If you are using the R programming language for data preprocessing, analysis,
and visualization---as well as RMarkdown for writing reports and
presentations---then you can use RStudio's "Project" functionality to make it
even more convenient to work with files within a research project's directory.
You can make any file directory a "Project" in RStudio by chosing "File" ->
"New Project" in RStudio's menu. This gives you the option to create a 
project from scratch or to make an existing directory and RStudio Project. 

When you make a file directory an RStudio Project, it doesn't change much in 
the directory itself except adding a ".RProj" file. This file keeps track of 
some things about the file directory for RStudio, includuing ... Also, when you
open one of these Projects in RStudio, it will move your working directory 
into that projects top-level directory. This makes it very easy and practical 
to write code using relative pathnames that start from this top-level of the
project directory. This is very good practice, because these relative pathnames
will work equally well on someone else's computer, whereas if you use file 
pathnames that are absolute (i.e., giving directions to the file from the root
directory on your computer), then when someone else tries on run the code on their
own computer, it won't work and they'll need to change the filepaths in the code, 
since everyone's computer has its files organized differently. For example, if you, 
on your personal computer, have the project directory stored in your "Documents" 
folder, while a colleague has stored the project directory in his or her "Desktop"
directory, then the absolute filepaths for each file in the directory will be
different for each of you. The relative pathnames, starting from the top level of 
the project directory, will be the same for both of you, though, regardless of 
where you each stored the project directory on your computer. 

There are some other advantages, as well, to turning each of your research
project directories into RStudio Projects. One is that it is very easy to
connect each of these Projects with GitHub, which facilitates collaborative work
on the project across multiple team members while tracking all changes under
version control. This functionality is described in a later module in this book.

As you continue to use R and RStudio's Project functionality, you may want to
take the template directory for your project and create an RStudio Project
template based on its structure. Once you do, when you start a new research
project, you can create the full directory for your project's files from within
RStudio by going to "File" -> "New Project" and then choosing to create a new
project based on that template. The new project will already be set up with the
".RProj" file that allows you to easily navigate into and out of that project,
to connect it to GitHub, and all the other advantages of setting a file
directory as an RStudio Project. The next module gives step-by-step directions
for making a directory an RStudio Project, and also how to create you own
RStudio Project template to quickly create a new directory for project files
each time you start a new research project.

### Subsection 1

One study surveyed over 250 biomedical researchers at the University of Washington. 
They noted that, "a common theme surrounding data management and analysis was that 
may researchers preferred to utilize their own individual methods to organize data.
The varied ways of managing data were accepted as functional for most present needs.
Some researchers admitted to having no organizational methodology at all, while others
used whatever method best suited their individual needs." [@anderson2007issues]
One respondent answered, "They're not organized in any way---they're just thrown into
files under different projects," while another said "I grab them when I need them, they're
not organized in any decent way," and another, "It's not even organized---a file on a central
computer of protocols that we use, common lab protocols but those are just individual 
Word files within a folder so it's not searchable per se." [@anderson2007issues]

> "In general, data reuse is most possible when: 1) data; 2) metadata (information
describing the data); and 3) information about the process of generating those data, 
such as code, are all provided." [@goodman2014ten]

> "So far we have used filenames without ever saying what a legal name is, so it's time for a couple
of rules. First, filenames are limited to 14 characters. Second, although you can use almost any 
character in a filename, common sense says you should stick to ones that are visible, and that you 
should avoid characters that might be used with other meanings. ... To avoid pitfalls, you would
do well to use only letters, numbers, the period and the underscore until you're familiar with the
situation [i.e., characters with pitfalls]. (The period and the underscore are conventionally used 
to divide filenames into chunks...) Finally, don't forget that case distinctions matter---junk, Junk, 
and JUNK are three different names." [@kernighan1984unix]

> "The [Unix] system distinguishes your file called 'junk' from anyone else's of the same name. The 
distinction is made by grouping files into *directories*, rather in the way that books are placed om 
shelves in a library, so files in different directories can have the same name without any conflict.
Generally, each user haas a personal or *home directory*, sometimes called login directory, that 
contains only the files that belong to him or her. When you log in, you are 'in' your home directory.
You may change the directory you are working in---often called your working or *current directory*---but
your home directory is always the same. Unless you take special action, when you create a new file it is
made in your current directory. Since this is initially your home directory, the file is unrelated
to a file of the same name that might exist in someone else's directory. A directory can contain
other directories as well as ordinary files ... The natural way to picture this organization is as a 
tree of directories and files. It is possible to move around within this tree, and to find any file in the system
by starting at the root of the tree and moving along the proper branches. Conversely, you can start where 
you are and move toward the root." [@kernighan1984unix]

> "The name '/usr/you/junk' is called the *pathname* of the file. 'Pathname' has an intuitive meaning:
it represents the full name of the path from the root through the tree of directories to a particular 
file. It is a universal rule in the Unix system that wherever you can use an ordinary filename, you can 
use a pathname." [@kernighan1984unix]

> "If you work regularly with Mary on information in her directory, you can say 'I want to work on Mary's
files instead of my own.' This is done by changing your current directory with the `cd` command...
Now when you use a filename (without the /'s) as an argument to `cat` or `pr`, it refers to the file
in Mary's directory. Changing directories doesn't affect any permissions associated with a file---if you
couldn't access a file from your own directory, changing to another directory won't alter that fact." [@kernighan1984unix]

> "It is usually convenient to arrange your own files so that all the files related to one thing are in a
directory separate from other projects. For example, if you want to write a book, you might want to 
keep all the text in a directory called 'book'." [@kernighan1984unix]

> "Suppose you're typing a large document like a book. Logically this divides into many small pieces, 
like chapters and perhaps sections. Physically it should be divided too, because it is cumbersome
to edit large files. Thus you should type the document as a number of files. You might have separate
files for each chapter, called 'ch1', 'ch2', etc. ... With a systematic naming convention, you can tell at
a glance where a particular file fits into the whole. What if you want to print the whole book? You could 
say `$ pr ch1.1 ch1.2 ch 1.3 ...`, but you would soon get bored typing filenames and start to make mistakes.
This is where filename shorthand comes in. If you say `$ pr ch*` the shell takes the `*` to mean 'any
string of characters,' so ch* is a pattern that matches all filenames in the current directory that 
begin with ch. The shell creates the list, in alphabetical order, and passes the list to `pr`. The
`pr` command never sees the `*`; the pattern match that the shell does in the current directory 
generates aa list of strings that are passed to `pr`." [@kernighan1984unix] 

> "The current directory is an attribute of a process, not a person or a program. ... The notion of a 
current directory is certainly a notational convenience, because it can save a lot of typing, but
its real purpose is organizational. Related files belong together in the same directory. '/usr' is
often the top directory of a user file system... '/usr/you' is your login directory, your current
directory when you first log in. ... Whenever you embark on a new project, or whenever you have 
a set of related files ... you could create a new directory with `mkdir` and put the files there." [@kernighan1984unix]

> "Despite their fundamental properties inside the kernel, directories sit in the file system as
ordinary files. They can be read as ordinary files. But they can't be created or written as 
ordinary files---to preserve its sanity and the users' files, the kernel reserves to itself all 
control over the contents of directories." [@kernighan1984unix]

> "A file has several components: a name, contents, and administrative information such as 
permissions and modifications times. The administrative information is stored in the inode
(over the years, the hyphen fell out of 'i-node'), along with essential system data such as 
how long it is, where on the disc the contents of the file are stored, and so on. ...
It is important to understand inodes, not only to appreciate the options on `ls`, but because 
in a strong sense the inodes *are* the files. All the directory hierarchy does is provide
convenient names for files. The system's name for a file is its *i-number*: the number of the
inode holding the file's information. ... It is the i-number that is stored in the first two bytes
of a directory, before the name. ...
The first two bytes in each directory entry are the only connection between the name of a file and its
contents. A filename in a directory is therefore called a *link*, because it links a name in the
directory hierarchy to the inode, and hence to the data. The same i-number can appear in more than
one directory. The `rm` command does not actually remove the inodes; it removes directory entries
or links. Only when the last link to a file disappears does the system remove the inode, and hence
the file itself. If the i-number in a directory entry is zero, it means that the link has been 
removed, but not necessarily the contents of the file---there may still be a link somewhere else." [@kernighan1984unix]

### Subsection 2

### Practice quiz

