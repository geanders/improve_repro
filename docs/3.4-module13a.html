<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="3.4 Tips for improving reproducibility when writing R scripts | Improving the Reproducibility of Experimental Data Recording and Pre-Processing" />
<meta property="og:type" content="book" />

<meta property="og:description" content="Online book with modules for improving the reproducibility of experimental data recording and preprocessing." />
<meta name="github-repo" content="rstudio/bookdown-demo" />

<meta name="author" content="Brooke Anderson, Michael Lyons, Mercedes Gonzalez-Juarrero, Marcela Henao-Tamayo, and Gregory Robertson" />



<meta name="description" content="Online book with modules for improving the reproducibility of experimental data recording and preprocessing.">

<title>3.4 Tips for improving reproducibility when writing R scripts | Improving the Reproducibility of Experimental Data Recording and Pre-Processing</title>

<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/envisioned.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="toc.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#rigor-and-reproducibility-in-computation" id="toc-rigor-and-reproducibility-in-computation"><span class="toc-section-number">1</span> Rigor and reproducibility in computation</a></li>
<li><a href="2-experimental-data-recording.html#experimental-data-recording" id="toc-experimental-data-recording"><span class="toc-section-number">2</span> Experimental Data Recording</a></li>
<li><a href="3-experimental-data-preprocessing.html#experimental-data-preprocessing" id="toc-experimental-data-preprocessing"><span class="toc-section-number">3</span> Experimental Data Preprocessing</a></li>
<li><a href="4-references.html#references" id="toc-references"><span class="toc-section-number">4</span> References</a></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="module13a" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Tips for improving reproducibility when writing R scripts</h2>
<p>This module is meant for researchers who are using R already as part of their
research. It is meant as a complement and alternative to the previous script,
which focused on readers who are new to creating code scripts.</p>
<p><strong>Objectives.</strong> After this module, the trainee will be able to:</p>
<ul>
<li>Improve the reproducibility of their scripts by leveraging tips meant for
researchers who are already incorporating scripts in their research</li>
</ul>
<div id="tips-and-guidelines-for-writing-code-scripts" class="section level3" number="3.4.1">
<h3><span class="header-section-number">3.4.1</span> Tips and guidelines for writing code scripts</h3>
<p>Learning to code can seem daunting, but it’s not any more difficult than
learning any new language. Many people from a variety of disciplines have
learned to code to help with their research. Doing so can pay big dividends in
terms of reproducibility and efficiency.</p>
<p>In this section, we’ll provide some tips to make it easier as you get started.
If you are new to coding, these can give you a framework for how to tackle what
can seem the daunting task of learning to code, as well as help you see that
there are approachable techniques. If you already know how to code, these tips
and guidelines can help in improving that code and give you some new directions
in how to code efficiently and reproducibly.</p>
<p><strong>Write code for computers, rewrite it for humans</strong></p>
<p>Even when code for a project is available, it can be hard to understand and
reproduce the analysis. One common culprit is that the code isn’t written for
humans to read. One way to improve the reproducibility of your code, therefore,
is to make sure you edit it so that it’s clear for humans, not just computers.</p>
<p>During World War I and World War II, the British and US used a special type of
camouflage on some of their ships called “dazzle camouflage”. This type of
camouflage uses large geometric shapes, often in black and white, and it makes
the ships look a bit like zebras. Unlike other types of camouflage, this type
doesn’t conceal the ship—it’s still very clear that it’s there. However, to
be able to hit a ship at sea, people needed to know not only where it was, but
also where it was going. This is because the ship will move some between the
time that a ballistic is fired and when it lands, and so the people needed to
calibrate for that movement and aim at where the ship would be by the time
the ballistic got to it. Dazzle camouflage makes it much harder to make out
where the ship is headed.</p>
<p>Often, people will write code for research projects that looks like it’s using
dazzle camouflage. It’s easy to see that there’s something there when you look
at the code script, but it’s very hard to figure out what it’s doing or where
it’s trying to go. This type of code will be hard for others
to figure out, and also it will be hard for you to figure out when you come
back to the code in the future.</p>
<p>The best way to avoid this type of code is to get into the practice of editing
your code. When you first write code, you don’t want to write it slowly and
carefully—rather, you’ll usually be best at figuring out how to get something
to work if you get in the flow and get down some code without worrying about
how clear it is. This is fine, but get in the habit of thinking of this as
just the first step: in your initial coding, you’re getting the code to work
for the computer, but later you will need to go back and clean up the code so
it’s clear for humans, too. Editing the code will make it easier to understand
(both by others and by you) and will also make the code easier to maintain and
extend in the future.</p>
<p>This idea is similar to writing. Many writing experts recommend that you consider
your writing process as having several stages. First, you want to write in a
drafting process, where you get your ideas on paper but without editing yourself
much. This is a stage of getting the ideas out. In a separate stage, you can
edit, and at this stage you want to have your audience clearly in mind, editing
to make the writing clear for them. By separating this, you can use your mind
in a more creative, less constrained way as you create ideas, and then in a
more critical way as you refine those ideas for your audience.</p>
<p>While this practice is familiar to many writers, it’s less well known as a
process that benefits coders, especially those who are not professional
programmers but rather who code as a small part of their larger work, like
researchers. If you don’t already, try adding in editing stages as you develop
your code. It is most helpful to take time to edit code if you’re still within a
day or two of writing it, so it’s helpful to work in this editing stage fairly
frequently. Since it often requires less energy and brain power than the initial
stage (getting the code to work with the computer), it can be helpful to
incorporate editing time at times in your day when your energy is otherwise low.
For example, taking ten or fifteen minutes to edit existing code can be a good
way to start coding for the day, before you get to the heavier lifting of
writing new code.</p>
<p>As you edit your code, there are a few specific things that you can do to make
it clearer for humans to read. Some editing steps that we will cover in this
module are:</p>
<ul>
<li>Improve the names you’re using within the code</li>
<li>Break up monolithic code</li>
<li>Add useful comments</li>
<li>Remove dead-end code</li>
</ul>
<p>Let’s take a closer look at how you can do each of these steps.</p>
<p>One important step when editing your code is to use better names for things like
data objects and columns within dataframes. When you’re coding quickly, you
might often use “placeholder” types of names for objects. For example, a coder
might tend to name objects “df” (for “dataframe”) or “ex” as they’re first
getting the code to work.</p>
<p>There’s no problem in using these types of generic names as you initially
develop your code. In fact, there’s a rich history of these placeholder
object names, and they even have a fancy name, <em>metasyntactic variables</em>.
Different coding languages have developed different ones that are popular,
as have coders in different countries. For example, many C programmers will
name things “foo” and “bar” as they initially work on their code, while
Italians often use the Italian words for different Disney characters
(“pippo”, “pluto”, “paperino”).</p>
<p>The problem isn’t in using these placeholder names; the problem is when you
don’t later edit your code to use better names. These generic types of names
will tell you nothing about what’s stored in each object when you go back
and read the code later. With better names for each object, you can read through
the code and in some ways it will document itself, without even needing to
read the code comments to figure out what’s going on.</p>
<p>There is a style guide that is focused on the tidyverse approach available
at <a href="https://style.tidyverse.org/syntax.html" class="uri">https://style.tidyverse.org/syntax.html</a>. It includes guidance on how to
select good names for objects in R within its section on “Syntax”. Generally,
some good principles include that the name of the object should give you an
idea of what’s contained in the object. For example, if you have a dataframe
that has the weights of mice from your experiment, it’s much better to name
it “mouse_weights” rather than something generic like “foo”. Some of the
other guidance will help make your life easier as a coder, including things
like using only lowercase letters.</p>
<p>You can also edit the names of columns within dataframes, which can help improve
the clarity of your code, especially since code will often reference specific
columns by name. Similar principles apply to column names: ideally, you want
their names to describe what they contain. There are also some rules that will
make it easier to work with the column names. For example, column names can
include spaces, but if they do, it makes using them within R harder. Each time
you refer to that column name, you have to surround the name in backticks so R
will process its full name as a single name, rather than thinking its name ends
at the first space. This becomes a pain as you write a lot of code that refers
to that column. It’s also helpful to keep column names fairly short, so you can
see the full name as you work with the dataset and resulting output.</p>
<p>When it comes to column names, some of your editing might be to improve on names
that you quickly wrote yourself as you coded. However, a common reason for
ungainly column names is that you’ve read in data from a file format like Excel,
where it was easy for the person who entered the data to include spaces and
special characters in the column names. In this case, there are some tools in
R that can help you quickly improve the column names. In particular, the
<code>janitor</code> package has a function called <code>clean_names</code> that will do a lot of the
work for you, including converting the name to lowercase, removing special
characters (like “*” and “&amp;”), and replacing spaces with underscores. If you
need to make more targeted changes to column names, you can do so using the
<code>rename</code> function from the <code>dplyr</code> package.</p>
<p>The next thing you can do to edit your code is to break up “monolithic” code—
that is, code that isn’t clearly divided to show sections or steps in the
process. When you’re first creating your code, you won’t want to take the time
to nicely organize it into logical sections. However, once you are ready to
edit your code, you will find that breaking into clear sections and labeling
them will help you and others navigate the code first at a higher level
(understanding the big picture of how it works by looking at the major
steps it takes) and only diving into the details of each section once the
big picture is clear.</p>
<p>Again, this process mimics the process used by many writers. It’s common to
create drafts and notes that lack clear organization, but instead are just
collecting the raw material that will be shaped into a final article or book.
However, this raw material then needs to be organized and edited to make it
into something that others can navigate and make sense of. The writer Robert
Caro famously wrote massive books about political figures like Robert Moses and
Lyndon Johnson. To wrangle all his research into books, he noted that,
“I can’t start writing until I’ve thought it through and can see it whole
in my mind.”</p>
<p>In a similar way, once you’ve gotten code to work, you should make sure you have
a clear picture of the whole process and how it tackles the problem at a
“big picture” level. One of these steps might be something like reading in
and cleaning the data, while another step might be identifying and addressing
outliers in the data. Once you’ve identified the big steps, try as much as
possible to group the code into these big steps, then you can use code comments
and blank lines in your code to separate these sections and label them to
describe what they’re doing.</p>
<p>As you do this, you might find that you move some of your code around in the
script, which is fine as long as it doesn’t affect the computer being able to
process the script. For example, one of your big steps might be loading in
packages you’ll need. Rather than having a lot of <code>library</code> calls sprinkled
throughout your code, you can group these all together at the start of your
script in a section called something like “Loading packages”. This will
clean up these calls from other parts of your script; also, by having all
your library calls at the start of the code script, another person could
immediately see which packages they’ll need to have installed to run your code.</p>
<p>Another way that you can break up monolithic code is to split it into more lines.
R will process the code whether it’s all on one line or split into separate
lines: R just keeps reading until it gets to the end of the function call
either way. This means that you can use the “Return” key to break up your code
lines so you’re always able to see the full line of code without scrolling.</p>
<p>One common standard is to keep all of your lines of code to 80 characters or
fewer. RStudio has the functionality to reformat your code to meet this
standard. In the RStudio menus, if you go to the “Code” menu, you can select
to “Reformat Code”. This can help clean up long lines of code in your editing
process.</p>
<p>As you are breaking up monolithic code, it can also be helpful to use
code comments to add notes about why you are doing certain things. In R, you
can add a code comment anytime after a <code>#</code> on a line; R won’t read anything
that comes after that symbol on a line. You can use this to add small messages
for humans that describes your code.</p>
<p>As you add these comments, keep in mind that it’s often more useful to
describe why you’re doing something rather than what you’re doing. With a lot
of R code—especially in the tidyverse approach—the functions often have
names that clearly describe what they do. For example, the function that
you use to rename a column is called <code>rename</code>, while the function that you
use to select certain columns is called <code>select</code>. Therefore, your code should
do a fairly good job of self-documenting in terms of describing what it’s
doing.</p>
<p>Instead, you can use code comments to remind yourself or others of
why you’re implementing certain steps. For example, rather than having a code
comment that says “Rename columns”, you could say, “The columns that come
from the Excel file generated by the cytometer include a lot of special
characters, which we need to remove to make it easier to work with the data in
R.” By explaining why you’re doing something, you’ll also help yourself when it’s
time to maintain or extend your code. You’ll be able to tell, for example,
whether changing or deleting a certain line of code will cause a big problem
in other areas of code.</p>
<p>Another useful step when you edit your code is to edit out pieces we’ll call
“dead-end code”. These are pieces of code that aren’t contributing to the
process of your script.</p>
<p>There are two main types of this dead-end code that we often see. First, there’s
code that you use during your interactive coding process to check on things. For
example, you might use the <code>View</code> function to take a look at a data frame at a
certain step in your process, or use functions like <code>summary</code> and <code>str</code> to
explore what’s in different objects.</p>
<p>It’s great to do this kind of exploration as you code; in fact, one of the
advantages of interactive software like R is that you can explore as you
develop your scripts. However, these are tools that help you develop a script,
but not ones that are necessary for the final script to run. Instead, they just
gunk up the code that’s doing the real work.</p>
<p>There are two things you can do regarding this type of dead-end code. The first
is that you can get in the habit of running it in your console, rather than
having it in your script, even when you’re developing the code. However, this
does require switching between the console and the script as you write code,
which can interrupt your flow. An alternative is to run these in a script as
you write the code, but then delete any of these exploratory calls as you
edit your script.</p>
<p>There’s also a second type of dead-end code. This is code that you were trying
out to solve a particular problem, but that ultimately didn’t work (or that
was superseded by a better approach). Often, you may have worked a long time
on that piece of code, or it might contain some really clever approach that
you’re proud of. However, leaving it your script, if it isn’t contributing to
the ultimate process you ended up with, will only get it the way of understanding
your primary code. It will lead a reader down a rabbit hole, rather than allowing
them to move step by step through your logic.</p>
<p>In writing, there are similarly areas that aren’t contributing to the forward
movement of a piece but that authors are reluctant to remove because they love
them for one reason or another. This has resulted in the famous advice to
authors (from Stephen King, among others) to “murder your darlings”. In other
words, be brave enough to edit out anything that isn’t contributing to the
necessary progress of your piece. Coders should take this advice in a similar
way when it comes to pieces of code in their scripts that don’t ultimately
contribute to the pipeline they’ve developed.</p>
<p><strong>Find favorite tools and get to know them</strong></p>
<p>The best thing that you can do to smooth the path as you learn a coding language
is to start by finding a few general purpose tools and learning to use them
really well. If you ask most good programmers, you will find that a large
amount of their code relies on a fairly small set of general-use tools,
with more specialized tools only used here and there, where a specific
algorithm is necessary.</p>
<p>[More on the importance of learning a few foundational tools well]</p>
<p>Later, we will talk about an approach called the “tidyverse” approach, which
focuses on sets of these general purpose tools. This approach allows you to
use the same set of tools for many problems, and it does so by focusing on
keeping your data in the same type of data structure (a tidy dataframe) for
as much of the pipeline as you can. This approach therefore fosters the
approach of starting by learning a small set of tools very well.</p>
<p>In later modules, we will recommend some of the tools that we have found to be
very helpful in preprocessing biomedical data, most of which are part of this
tidyverse. These include tools for adding or modifying columns to a dataframe,
inputting data from common file formats, and so on. However, this strategy is
not unique to the R programming language and is a good strategy to adopt
regardless of the programming language you are learning.</p>
<blockquote>
<p>“The functional orientations of Shepherd-Barron and the Wright brothers
(or Edison) have one thing in common. It’s what the Santa Fe Institute
scholar Brian Arthur calls <em>deep craft</em>—the ability to know intimately
the various functionalities and how to effectively combine them. ‘It
consists in [knowing] what is likely not to work, what methods to use,
whom to talk to, what theories to look to, and above all of how to
manipulate phenomena that may be freshly discovered and poorly understood’,
Arthur writes. Systems-engineering approaches that underline the
efficiency and reliability of failure-tolerance products like ATMs and
airplanes have a strong connection to deep craft.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<p><strong>Modify rather than start from scratch</strong></p>
<p>As you code, keep in mind that you shouldn’t reinvent the wheel. There are
excellent resources available that can help provide you with a starting
point for many of the coding tasks you’ll need to do. For example, most
packages have tutorials called vignettes that provide a starting point
in how to use the package, and helpfiles often include short example code
that you can adapt to your own purposes. Online resources like StackOverflow
also provide advice and example code for many challenges you might come up
against as you’re coding. Google can also be used to help you solve coding
problems, espeically if you become familiar with some of its special
operators, which can help you refine your search (see <a href="https://support.google.com/websearch/answer/2466433?hl=en" class="uri">https://support.google.com/websearch/answer/2466433?hl=en</a> for more on this).</p>
<p>There’s no problem with using any of these as starting points as you develop
your own code. However, it’s often tempting for a coder to leave some lines
of code “as-is” if they’ve found an example solution that works. Instead, it’s
critical that you make sure you fully understand why each line of code in your
script works the way it does. Further, if you’re adapting example code to
your own problem, you should edit it if possible to use the set of tools you’re
most familar with.</p>
<p>When you find a piece of example code that you think will help with something
you need to do in your own code, you’ll first want to make sure that you can
get it to work with any example data it came with, before you try it out with
your own data. If it won’t run with its own data, there are a few trouble-shooting
steps you can take. First, make sure you have all the required packages
installed and loaded. Second, make sure that you’ve saved the example data
to the right place on your computer if the example code reads in data from
a file. Finally, make sure that you have the same versions of
packages and of R. If the code still doesn’t work after you’ve resolved these
issues, you may want to move on to finding other example code.</p>
<p>Once you’ve gotten the code to run on the example data, walk through it line
by line to understand what it does. For each step, make sure you understand
what the input looks like and what the output looks like. If code is nested
(function calls are placed within function calls), be sure that you understand
the code at each level of nesting. If the code uses piping to move the output
of one call to the input of the next, make sure you’ve worked through each
of the lines in the pipe individually.</p>
<p>There are two tools that can help as you dissect the code in this way. First,
when you work in R study, you can highlight code in a script and then use the
“Run” button to run only that code. This functionality allows you to run a
nested function call without running the whole line of code, or to run only part
of a series of piped calls (by highlighting everything up to the piping symbol
on a line and then running it). The other tool that’s useful is a function in
the <code>dplyr</code> package called <code>pull</code>. This function allows you to extract a column
from a dataframe as a vector. This is helpful when you’re dissecting nested
calls in piped code, as often a function will operate on a single column of the
dataframe. This function allows you to pull out that column and then test the
function call to see what it’s doing with that column.</p>
<p>Once you figure out what the example code does on the data it comes with, you
can adapt it to work with your own data. As you do, pay close attention to
how your data are similar or different to the example data. At this stage, your
goal will be to get the example code to work with your data.</p>
<p>Many researchers stop at this step—they’ve gotten example code to work with
their own data (and hopefully worked through it to understand why). However,
example code often follows a very different style than code you write yourself.
For example, you may use the tidyverse approach, while the example might use
code written in a base R style. Further, different coders think about and
tackle problems in different ways, which can lead to the case where any
example code that you’ve adapted in your script feels different from your usual
code.</p>
<p>This can result in spots of your code that you will later be very worried to
change, because while it works, you don’t understand why well enough to feel
comfortable making any change. This can make your code fragile and hard to
maintain. Instead, take a moment to adapt the logic that you’ve learned from
the example to use your own set of tools. For example, if the example code is
written in base R but you prefer tidyverse tools, rewrite the code’s logic
to use tidyverse tools.</p>
<p>You gain several advantages when you adapt code to use the tools you’re familiar
with. For example, bugs will be less likely, and if there are bugs, you’ll
catch them more quickly, since you’re familiar with the tools that the code is
using. The code will also be much easier for you to understand and maintain in
the future.</p>
<blockquote>
<p>“The sandbox of the budding builder is not <em>making</em> as much as it is
modification: taking something that exists and making it better, either
functionally or aesthetically or both. Often that involves attaching and
securing parts that were not originally intended to go together.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<p>As you start learning to write code in R, don’t force yourself to stare at an
empty R script file and try to come up with a full script from scratch. One of the
best ways to learn R is to find some scripts that others have written for tasks
that are similar to the ones that you want to do, then work through those to figure
out each function call, and how those function calls add up to the full pipeline.</p>
<p>This method of reverse engineering is useful in many areas when you’re trying to
figure out how things work. …</p>
<p>Once you understand a few other R scripts, you can start trying to modify them and
to pull pieces from different scripts to use as building blocks as you put together
your own script. There’s no need to reinvent the wheel—if someone else has
shared an R script that comes close to doing what you need to do, start there and
then change and evolve that idea to suit your own needs.</p>
<p>To find some starting scripts to learn from, there are a few tactics you can try.
First, check around with colleagues to see if they have R code for data preprocessing
tasks that they do in their lab. If they work with similar types of data, and use R,
they’re likely to have come up with some scripts that achieve tasks you also need to
do.</p>
<p>Another excellent source of example R code are the vignettes and examples that come
with many R packages. If you are using functions from an R package, then there is likely
a vignette that comes with that package, and there may also be examples within the
helpfiles for each of the package’s functions. A package vignette is a tutorial that
walks you through the major functionality of the package, showing how to use the
key functions in the package in an extended example. Some packages will have multiple
vignettes, showing a range of things that you can do with the package.</p>
<p>To find out if there is a vignette for a package that you’re using, you can google the
package name and “vignette”. You can also find out from the console in R using the
function <code>vignette</code>. For example, to find out if the package <code>readxl</code>, which we used
in the earlier code example, has any vignettes, you can run <code>vignette(package = "readxl")</code>.
This will tell you that the package has two, one called “cell-and-column-types” and
one called “sheet-geometry”. To open one of these, you can again use the <code>vignette</code>
function. For example, <code>vignette("cell-and-column-types", package = "readxl")</code> would
open the first of the two vignettes.</p>
<p>To open the helpfile for any function in R, at the console type a question mark and then
the function name. For example, <code>?read_excel</code> will open the helpfile for the <code>read_excel</code>
function (you will need to make sure you’ve run <code>library("readxl")</code> to load the package
with this function). The helpfile provides useful information for running the function,
and one of the most useful parts is the “Examples” section. Scroll down to the bottom
of the helpfile to find this section. It includes several examples that you can copy into
your R script or console and try yourself, to figure out the types of inputs that the
function needs and how different options for the function modify how it works.</p>
<blockquote>
<p>“All creative work builds on what has gone before. When someone declares
that something is original, it’s because they are unaware of the influences.
The creative make the most of things they admire and aren’t ashamed to
be inspired by something they respect. The bad news: everything has already
been done. The good news: it can be done again.” <span class="citation">(Judkins 2016)</span></p>
</blockquote>
<blockquote>
<p>“Extracting penicillin from the mold was no child’s play… Instead of
designing and building a reactor for the chemical reactions from scratch—which
meant more time, money, and uncertainty—[Margaret] Hutchinson opted for something
that was already functional. Some researchers had found that mold from
cantaloupe could be an effective source for penicillin, so she started
there. Her team then revised a fermentation process that Pfizer was using to
produce food additives like citric acid and gluconic acid from sugars, with
the help of microbes. Hutchinson swiftly helped convert a run-down
Brooklyn ice factory into a production facility. The deep-tank fermentation
process produced great quantities of mold by mixing sugar, salt, milk, minerals,
and fodder through a chemical separation process that Hutchinson knew very
well from the refinery business.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<blockquote>
<p>“Johannes Gutenberg invented his printing press by repurposing a wine
press for use with olive oil–based ink and block printing.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<p>However, it is critical that you work through and understand any example code
that you bring in and modify in your own workflow.</p>
<blockquote>
<p>“Appropriate methods are ‘very data-set dependent’… The methods and tuning
parameters may need to be adjusted to account for variable such as sequencing
length. But John Marioni at Cancer Research UK in Cambridge says it’s important not
to put complete faith in the pipeline. ‘Just because the satellite navigation
tells you to drive into the river, you don’t drive into the river,’ he says.”
<span class="citation">(J. M. Perkel 2017)</span></p>
</blockquote>
<blockquote>
<p>“Do not reinvent the wheel. It pays to reuse existing software. Integrative
frameworks and associated application stores already house hundreds of tools
(for example, as of May 2012, Galaxy ToolShed contains ~ 1,700 tools). It is
likely that a script for a particular problem has been already written. Ask
around through existing resources such as SEQanswers43 and BioStar44.”
<span class="citation">(Nekrutenko and Taylor 2012)</span></p>
</blockquote>
<blockquote>
<p>“If you’re going to build a house today, you don’t start by cutting down trees to make
lumber and digging clay to make your own bricks. Instead, you buy prefabricated pieces like
doors, windows, plumbing fixtures, a furnace, and a water heater. House construction is still
a big job, but it’s manageable because you can build on the work of many others and rely
on an infrastructure, indeed an entire industry, that will help. The same is true of
programming. Hardly any significant program is created from nothing. Many components written
by others can be taken off the shelf and used. For instance, if you’re writing a program for
Windows or a Mac, there are libraries of prefabricated menus, buttons, text editors, graphics,
network connections, database access, and so on. Much of the job is understanding the components
and gluing them together in your own way. Of course, many of these components in turn rest on
other simpler and more basic ones, often for several layers. Below that, everything runs on
the operating system, a program that manages the hardware and controls everything that happens.”
<span class="citation">(Kernighan 2011)</span></p>
</blockquote>
<blockquote>
<p>“There is also a problem with discovering software that exists; often people
reinvent the wheel just because they don’t know any better. Good repositories
for software and best practice workflows, especially if citable, would be a
start.” — James Taylor in <span class="citation">(Altschul et al. 2013)</span></p>
</blockquote>
<p><strong>Modular, not monolithic</strong></p>
<p>Another key thing to remember as you develop R scripts is that they are all,
even those that do very complex things, made up of lots of smaller, simpler
pieces. R scripts are, in other words, modular, not monolithic.</p>
<p>As you develop a script, plan to create it by chaining together simpler steps. You can
start by trying to map out the key things that you’ll need to do in the pipeline, and
then you can dive into each of those sections and start writing the code to
achieve that step. For example, if you are preprocessing data that measured bacterial
growth rates, some of the broad sections you may have in your pipeline are ones
to read in the data, to convert it into a tidy data format so it’s easier to work
with, to determine the time range in the experiment when each sample was in its
exponential growth phase, to use data in that time range to estimate the growth
rate for each sample, and so on. Start by dividing your script into these sections
(you can mark each off with a code comment—how to use these are described
later in this section), and then you can start to develop the code, starting with
the code to input the data.</p>
<p>Thinking of a code script as something that is modular is critical as you start
learning how to code in a language like R. By dividing the full pipeline into smaller
steps, you can tackle it one piece at a time. You can look for resources that are
linked to a specific part of the problem, rather than feeling like you need to
find other examples of full, start-to-finish pipelines that have done the same thing
that you’re trying to do. For example, the step of reading in data that you recorded
in an Excel spreadsheet comes down to a simple task—reading data into R from an
Excel file. It doesn’t matter whether that file has data on bacterial growth rates
or on mice weights or on anything else—the process of reading it into R is the
same. Therefore, when you’re working on this step, you can google help on reading
Excel files into R if you’re stuck, without worrying about whether the resources
that you find to help used examples of the type of data you have or other types of
data.</p>
<blockquote>
<p>“The core of the engineering mind-set is what I call modular systems thinking.
… A specific technique in modular systems thinking, for example, includes
a functional blend of deconstruction (breaking down a larger system into
its modules) and reconstructionism (putting those modules back together). The
focus is on identifying the strong and weak links—how the modules work,
don’t work, or could potentially work—and applying this knowledge to
engineer useful outcomes. … there’s a top-down design strategy—‘divide
and conquer’—in which each subtask is separately attacked in a progression
toward achieving the final objective.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<blockquote>
<p>“Psychologist Gary Bradshaw has written about the importance of function-based
design in the development of airplanes. Wilbur and Orville Wright took about four
years to implement their first prototype of a flying machine. While their
competitors focused on the design of winds, fuselage, and propulsion, the
Wright brothers were devoted to getting the fundamental functions of lift,
thrust, drag, and yaw correct. Consistent with the notion of modular thinking,
they solved each puzzle at a subsystems level before they moved to the
next layer of the assembly, and along the way they invented new instruments and
measurement techniques.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<blockquote>
<p>“Very little of what I’ve built over the years is monolithic—just a single chunk.
Most of the time, I build things in components, then attach those pieces together
as I go. So yes, the component parts are pieces that have been made small in
precise ways from larger chunks of material, but eventually they will be assembled
to create much larger and more complex objects than any of the raw source materials.”
<span class="citation">(Savage 2020)</span></p>
</blockquote>
<p><strong>Iterate!</strong></p>
<p>Code is something that you develop over multiple drafts—it’s the kind of thing
that you build by trying out one thing, seeing how it works, then revising, reworking,
and extending to get to the pipeline you ultimately want. You will quickly feel
frustrated if you try to build your pipelines in a single go, without this process
of iteration. Just as many writers suffer writer’s block more often when they
try to get everything perfect in a first draft, you will feel frustrated if you
think that you should build your code to its final form, from start to
finish, in just one try.</p>
<p>When you build a code pipeline, try to break your process up into some key chunks.
For example, you might know that you’ll first need to input the data into R
(first chunk), then preprocess the data by log-transforming one of the measurements
(second chunk), and then run a statistical hypothesis test to compare two groups
that you measured (third chunk). Once you’ve broken the code into these chunks,
you can focus on a single chunk at a time and iterate the code for that task until
you’re happy with it.</p>
<p>For example, if the first chunk is to read in the data, you might first try to
use a standard tool that you’ve used before, like the <code>readr</code> function <code>read_csv</code>,
which reads in data from a CSV file. However, maybe this tool doesn’t work for
the file format your data are in (perhaps they’re in an Excel file, for example),
and so you get an error when you try to do that. Keep calm when you get that error,
and just iterate back and look up some tools for reading Excel files into R.
When you’ve found some, try adapting the examples from their help files or vignettes
to work in your code pipeline. If that works, then spend some time exploring the
input that you get, so you can start to think about how you’ll work with the data
for the next chunk in your pipeline.</p>
<p>Once you’re done with this process of iteration, make sure that you go back and
clean up the code pipeline, so that the code script is streamlined to walk
efficiently through the tasks. Also, rerun the whole script in a new R session,
so you can make sure that it is self-contained. One of the most common
reasons for a script not working the same later is that, when it was originally
developed, the coder was relying on some objects that were created in their R
environment at the console, not through code in the script, and so were available
when running the code originally, but not when it’s opened in a new R session.
You can often identify and fix these issues much more quickly by testing your
code pipeline in a new R session right after you create it, rather than
waiting and running into that problem days or weeks later, when you try to rerun
the script.</p>
<blockquote>
<p>“Prototypes create new capabilities. Prototypes foster adaptation to new
forms, new expections, and new offshoots of technologies. Prototypes are
the starting points toward our ultimate creative destinations.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<blockquote>
<p>“Tweaking and prototyping are basic human habits.” <span class="citation">(Madhavan 2015)</span></p>
</blockquote>
<blockquote>
<p>“Programming in the real world tends to happen on a large scale. The strategy is similar
to what one might use to write a book or undertake any other big project: figure out what
to do, starting with a broad specification that is broken into smaller and smaller pieces,
then work on the pieces separately, while making sure that they hang together. In programming,
pieces tend to be of a size such that one person can write the precise computational steps
in some programming language. Ensuring that the pieces written by different programmers
work together is challenging, and failing to get this right is a major source of errors.
For instance, NASA’s Mars Climate Orbiter failed in 1999 because the flight system software
used metric units for thrust, but course correction data was entered in English units,
causing an erroneous trajectory that brought the Orbiter too close to the planet’s
surface.” <span class="citation">(Kernighan 2011)</span></p>
</blockquote>
<blockquote>
<p>“Developing code in R is a back-and-forth between writing code in a rerunnable script
and exploring data interactively in the R interpreter. To be reproducible, all steps
that lead to results you’ll use later must be recorded in the R script that accompanies
your analysis and interactive work. While R can save a history of the commands you’ve
entered in the interpreter during a session (with the command <code>savehistory()</code>),
storing your steps in a well-commented R script makes your life much easier when you
need to backtrack to understand what you did or change your analysis.” <span class="citation">(Buffalo 2015)</span></p>
</blockquote>
<blockquote>
<p>“People not doing the computational work tend to think that you can write a
program very fast. That, I think, is frankly not true. It takes a lot of time to
implement a prototype. Then it actually takes a lot of time to really make it
better.” — Heng Li in <span class="citation">(Altschul et al. 2013)</span></p>
</blockquote>
<p><strong>Do not repeat yourself</strong></p>
<p>As you become more familiar with programming with R, you can start to evolve your
style of writing scripts in more advanced ways. A key one is to learn how to limit
how often you repeat the same code. As you write data preprocessing pipelines, you’ll
find that you often need to do the same thing, or variations on the same thing, over
and over. For example, you may need to read in and clean several files of the same
type and structure. You will likely, at first at least, find yourself copying and
pasting the same code to several parts of your script, with only minor changes to
that code (e.g., changing the R object that you input each time).</p>
<p>Don’t worry too much about this as you start to learn how to write R scripts. This
is a normal part of the drafting process. However, as you get better at using R, you’ll
want to learn techniques that can help you avoid this repetition.</p>
<p>There are a few reasons that you’ll want to avoid repetition in your code when
possible. First, these repeated copies of the same or similar code will make your
code script much longer and harder to read through later to figure out what you did.
Second, it is hard to keep these copies of code in sync with each other. For example, if
you have several copies of the code you use to check for outliers in your data, and you
decide you want to change how you are doing that, you’ll need to find every copy of
the code in your script and make sure you make the same change in each place. Instead,
if you have less repetition in your code, then you can make the change in a single place
and ensure that the change will be in place everywhere you are doing that process.</p>
<p>There are a few tools that are useful to develop to help avoid repetition. The first
is to learn how to write your own R functions. Any R user can write a new function, and
you can write these for your personal use, in addition to writing them in packages you
plan to share with others. When you wrap a function, it encapsulates the code for something
that you need to do, and it allows you to do that thing anywhere else in your code
just by calling that new function, rather than copying all the lines of the original code.
This is an excellent way to write the code you need to use often in one place, rather than
copying and pasting the same code throughout your R script.</p>
<p>Since you need to run the code that defines the function before you use it, it
often makes sense to write any code that creates these functions near the top of
your code script. If you find that you’ve written a lot of functions, or that
you’ve written functions that you’d like to use in more than one of your data
preprocessing scripts, you can even save the code that creates the functions in
a separate R script and just source that separate script at the top of each
script that uses the function, using the <code>source</code> call (and eventually you could
even think of creating your own package with those functions).</p>
<p>There is one other excellent set of tool for avoiding repetition that we want to mention.
Again, it is likely more complex that what you’ll want to start off with as you
learn to write R scripts, but once you are comfortable with the basics, it’s a
powerful tool for creating code scripts that are as short and simple as possible
while doing very powerful things. This set of tools all focus on iteration. They
include <code>for</code> loops, which allow you to step through elements in a data structure
and apply the same code to each. They also include a set of tools in the <code>purrr</code>
library that allow you to apply the same code, through a function, to each element
in a larger data structure. These are excellent tools when you are doing something
like reading in a lot of similar files and combining them into a single R object for
preprocessing.</p>
<p>We will not go into details about how to write R functions or these iteration
tools in these modules, as our aim here is to get you started and give you an
overview of where you might want to go next. If you do want to learn to write
your own R functions, there’s a chapter describing the process in the free
online book “R for Data Science” with guidance on this topic
(<a href="https://r4ds.had.co.nz/functions.html" class="uri">https://r4ds.had.co.nz/functions.html</a>). If you’d like to learn more about tools
for iteration, the same book also has a chapter on that
(<a href="https://r4ds.had.co.nz/iteration.html" class="uri">https://r4ds.had.co.nz/iteration.html</a>).</p>
<blockquote>
<p>“Software, like many other things in computing, is organized into layers, analogous to
geological strata, that separate one concern from another. Layering is one of the important
ideas that help programmers to manage complexity.” <span class="citation">(Kernighan 2011)</span></p>
</blockquote>
<blockquote>
<p>“At the simplest level, programming languages provide a mechanism called functions that make
it possible for one programmer to write code that performs a useful a useful task, then package
it in a form that other programmers can use in their programs without having to know how it
works.” <span class="citation">(Kernighan 2011)</span></p>
</blockquote>
<blockquote>
<p>“<strong>Use functions.</strong> It’s better than copy-pasting (or repeatedly source-ing)
stretches of code.” <span class="citation">(Holmes and Huber 2018)</span></p>
</blockquote>
<blockquote>
<p><strong>Use the R package system.</strong> Soon you’ll note recurring function or variable
definitions that you want to share between your different scripts. It is fine to
use the R function <code>source</code> to manage them initially, but it is never too early
to move them into your own package—at the latest when you find yourself staring
to write emails or code comments explaining to others (or to yourself) how to use
some functionality. Assembling existing code into an R package is not hard, and it
offers you many goodies, including standardized ways of composing documentation,
showing code usage examples, code testing, versioning and provision to others.
And quite likely you’ll soon appreciate the benefits of using namespaces.”
<span class="citation">(Holmes and Huber 2018)</span></p>
</blockquote>
<p>Some tools that can help you avoid repetition include:</p>
<ul>
<li>Faceting in <code>ggplot2</code></li>
<li>The <code>map</code> family of functions in the <code>purrr</code> package</li>
<li>The <code>group_by</code> and <code>summarize</code> / <code>mutate</code> workflow in the <code>dplyr</code> package</li>
</ul>
<p><strong>Scripts are for humans to read, not just computers</strong></p>
<p>A code script, by definition, is a set of instructions that you send to the
computer to evaluate. However, many starting programmers make things hard
on themselves by treating the script as a document that is only for the computer.</p>
<p>While it is true that the code script needs to be written so that the
computer can evaluate it, that is only the first level of usefulness for the
script. Keep in mind that one of the key advantages of writing a computer
script is so that the code becomes reproducible—you and others can revisit
it, rerun it, and adapt it at a later time. Otherwise, in a programming
language like R, you could just run all your code at the console, rather than
saving it in a script.</p>
<p>To make sure that your code is “legible” by humans, take the time to clean it
up once you have it running. (As an added bonus, it’s often the case that you’ll
find a few bugs when you do so, and so you can catch and fix those.) Go back
through the whole script once you have built your pipeline.</p>
<p>Use comments! In R, and line that starts with a “#” will be ignored by R, so you
can use those to write messages for humans that the computer will skip. You can
use comments in a variety of ways to make your code clearer to humans. First,
you can use them to divide the code script into sections and to label those
sections. This will help a human reader get an overview of the script when
they first look at it and navigate the script as they continue to work with it.
You can also use code comments to explain coding choices that you’ve made along
the way that might not immediately be clear. For example, if you needed to
use a function that is outside of your core set of tools, and that you found
to tackle a specific problem, you could comment on that, and perhaps add a link
to more information on that function.</p>
<p>You can also clean up the code substantially by editing it to follow a set of
style guidelines for R code. These are guidelines that specify things that
don’t matter to the computer, but that can help human readers. For example,
there are many cases where R can evaluate code the same way whether spaces
have been used to separate pieces of the code or not, but a thoughtful use of
spacing can help a human read the code. There are several style guidelines
available for R and other programming languages, and it is less important which
one you use than that you follow one consistently (at least by the time you
edit your code for clarity to humans). One style guide you can use is the
one created by Hadley Wickham available at: <a href="https://style.tidyverse.org/index.html" class="uri">https://style.tidyverse.org/index.html</a>.</p>
<p>Finally, it is useful to use this editing stage to simplify the logic and
function calls within the script. Often, when you are first trying to get some
code to work, you might come up with a pretty ungainly function call to do
so. Once you’ve gotten it working and figured out a general approach, you can
often go back and rethink how you’ve coded the approach, and you can often
come up with a simpler way to perform the same task using less code or
clearer code. The more you can simplify your code, the lower the risk for
bugs and the easier it will be for humans to understand.</p>
<blockquote>
<p>“Filming [of Apocalypse Now] started in March 1976 and was scheduled to
take six weeks. It took sixteen months. The director, Francis Ford Coppola,
shot around 230 hours of footage, with multiple takes of the same scene. He
was hoping to capture a magical or unusual performance. He encouraged the
actors to ad-lib, which produced some poetic moments but also hours of unusable
footage. Once filming was finished, the movie had to be cut and recut for
months. It took Coppola and his film editor Walter Murch nearly three years to
edith the footage… Why produce a lot of work and then throw away 95 percent?
The two processes seem contradictory. Why not just produce the 5 percent ultimately
used? Because you don’t know <em>which</em> 5 percent that will be. Editing can
be hard becuase you’re discarding things you have put a lot of energy into
making.” <span class="citation">(Judkins 2016)</span></p>
</blockquote>
<blockquote>
<p>“You might not write well every day, but you can always edit a bad page.
You can’t edit a blank page.” – Jodi Picoult, cited in <span class="citation">(Judkins 2016)</span></p>
</blockquote>
<blockquote>
<p>“That a language is easy for the computer expert does not mean it is
necessarily easy for the non-expert, and it is likely non-experts who will do the
bulk of the programming (coding, if you wish) in the near future.” <span class="citation">(Hamming 1997)</span></p>
</blockquote>
<blockquote>
<p>“The code that a programmer writes, whether in assembly language or (much more likely) in
a high-level language, is called <em>source code</em>. … Source code is readable by other programmers,
though perhaps with some effort, so it can be studied and adapted, and any innovations or ideas
it contains are visible.” <span class="citation">(Kernighan 2011)</span></p>
</blockquote>
<blockquote>
<p>“<em>Document your methods and workflows.</em> This should include full command lines (copied
and pasted) that are run through the shell that generate data or intermediate results.
Even if you use the default values in software, be sure to write these values down;
later versions of the program may use different default values. Scripts naturally
document all steps and parameters …, but be sure to document any command-line options
used to run this script. In general, any command that produces results in your work needs
to be documented somewhere.” <span class="citation">(Buffalo 2015)</span></p>
</blockquote>
<p><strong>Some things belong in the console, not the script</strong></p>
<p>Finally, keep in mind that all of the code you write, as you develop a script with
a pipeline, does <em>not</em> need to be recorded in the script. Of course you will want
to include all the code that is necessary for the script as a whole to work on its
own. However, as you develop code, you’ll take some steps to explore your data or
to do things like installing packages that you don’t have yet.</p>
<p>For example, as you work on your code, you’ll likely want to look at the contents
of your R objects as you work on them. If you have read in your data from a file into
an R object, you’ll want to look and make sure it looks like it read in correctly.
If you have created a new object that summarizes the original data by taking the
average of each group, you’ll probably want to look at that as you develop the code
to create it, again to check and explore as you build the code. To do this, you can
call the object’s name (e.g., type <code>my_data</code> and run it) or use functions like
<code>head</code>, which prints out the first few rows or items of the object (e.g., <code>head(my_data)</code>),
<code>tail</code>, which prints out the last few rows or items of the object, or <code>str</code>, which
summarizes the structure and contents of the object.</p>
<p>All of these are useful to run as you draft and edit your code, but calls like this that
print out pieces of the data to check aren’t necessary in the final R script (and in
fact can make it messier than it needs to be and result in a lot of extra print-out at
the console when you run the code as a batch once you’ve finalized it). As you develop
your code, then, try to get in the habit of not writing these types of exploratory
function calls in the script you’re developing. Instead, write them directly in the
console and run them from there.</p>
<p>[Figure—writing exploratory code in the console versus the R script. Same for installing
packages]</p>
<p>The other piece of code that you should run in the console rather than saving in
the R script is code to install new packages. Since you only need to install a
package once (until you get a different computer or update base R), you don’t
need to run <code>install.package</code> function calls everytime you run the code in a
script. Including these functions in the script will therefore just slow it
down. Instead, go to your console directly to write the function calls to
install new packages (or, if you prefer, in RStudio you can go to Tools on the
menu bar and select Install Packages).</p>
<p>The final goal is to develop an R script that has everything it needs to run the
full pipeline from in a fresh R session. In other words, if it uses functions
from packages, it will include the code to load those packages (<code>library</code>
function calls). For every R object that it uses, there will be code that
creates that object in the script. It will not include, however, extra pieces of
code that were used to explore the objects as you built the code. To test that
the R script can run in a fresh R session, you can close R and reopen it (make
sure that you’ve set your global options in R to never save the workspace to
.Rdata on exit, to not restore the .Rdata into the workspace on exit, and to not
save the history, all of which you can set by going to the RStudio Tools menu
item and selecting Global Options). When you reopen R, there will not be any
objects in the environment, and there will not be a history of any of the
previous function calls that you ran. Try running the code in the script in this
fresh environment and make sure that you weren’t relying on anything that you
did outside the script to make the code work. If the code can run in a fresh
environment like this, then any R user should be able to rerun everything in the
script themselves (although they may need to install a few new libraries first
if they don’t have all the required libraries yet).</p>
</div>
<div id="discussion-questions-3" class="section level3" number="3.4.2">
<h3><span class="header-section-number">3.4.2</span> Discussion questions</h3>
<hr />
</div>
<div id="potential-quotes" class="section level3" number="3.4.3">
<h3><span class="header-section-number">3.4.3</span> Potential quotes</h3>
<blockquote>
<p>“Every maker needs to give themselves the space to screw up in the pursuit of
perfecting a new skill or in learning something they’ve never tried before.
Screwing up IS learning.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“Mistake tolerance is particularly valuable in this aspect of the creative
process. When you know what you want to make, but you’re not exactly sure what
it should look like or how it should operate, you need to give yourself permission
to experiment, to iterate your way there. That’s not just how you get to what you
want, it’s how you get good at it. You have to do it over and over and over
again. Anticipating mistakes is how you put space around the unfamiliar and
the unknown.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“If you expect to nail it the first go round every time you build something
new—or worse, you demand it of yourself and you punish yourself when you come
up short—you will never be happy with what you make and making will never
make you happy”. <span class="citation">(Savage 2020)</span></p>
</blockquote>
<p>BioC Conference</p>
<blockquote>
<p>“Just as writing a book involves an outline and a rough draft (so many drafts!),
which get polished into a final manuscript, making things often benefits from a
preliminary stage where the big details get worked out, and then a final fabrication
stage where the small details get worked out. Cardboard is a low threshold material
that can make discussion of ideas at the perliminary stage so much easier and
more complete.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“In my professional life, I have worked with every conceivable type of client and
collaborator, from those who were makers with the same or greater expertise as me,
who understood deeply what I was talking about when we discussed a build, to clients
who couldn’t glue two blocks of wood together if you put the blocks in their hands,
covered with glue, and told them to clap. Being able to communicate your ideas to
clients and collaborators is one of the most important skills to possess as a maker,
otherwise some of your projects may never get off the ground.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“To make anything, it’s critical to have a physical understanding of how all the
component parts of your project will fit together.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“What material can you wrap your arms around to gain a complete sense for the skills
you want to master and the objects you want to make? Is it cardboard? Muslin fabric?
Crappy butcher cuts? Scrap wood? The backside of recycled printer paper? A word
processor? It really doesn’t matter as long as it allows you to be messy and it
keeps you moving forward in your journey as a maker.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“Once you have a new tool you thing you need, spend some time getting to know it
physically. With certain tools, I’ll go so far as to take them apart, just to
understand them better, inside and out. … If you are unfamiliar with a tool or
inexperienced with the techniques required to use it, getting comfortable like this
is the most important thing you can do, because you might really need this thing, but
if you are intimidated by it, you aren’t going to want to use it, and then
what’s the point?” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“If you’ve never used a tool before, reviews and articles about it can only get
you so far. You need to work with a tool in order to see how the tool works for YOU.
You need on-the-ground experience with it in your hands.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<p>With open-source, you can think of it as builing a collection of different tools,
rather than a black box. The tools can come from different companies (like real tools)—you
don’t have to limit to consuming the tools created by a single producer (as with
most proprietary software systems).</p>
<p>For free and open-source software, you don’t have to invest money to get more tools.
Instead, the investment for each new tool is the time that it takes to learn how
to use it in your workflow. This includes several elements. You’ll need to understand
what primary input is used by the function, both in terms of the input’s conceptual
content and the format or structure in which those data are stored. You’ll need to
understand the content and format of the output of the function in a similar way, so that
you can join it with other functions in your workflow. You’ll want to make sure
you understand the main choices that you can modify with the function, through setting
different parameters, as well as the reason behind the defaults that are used for
those parameters. Finally, ideally you’ll want to understand a bit about how the
function operates to move from the input you give it to the output it gives back to
you.</p>
<blockquote>
<p>“‘Freemon Dyson, a famous physicist, suggested that science moves forward by
inventing new tools,’ Kevin [Kelly, founding editor of Wired magazine] began as
we talked on the phone one morning about tools. ’When we invented the telescope,
suddenly we had astrophysicists, and astronomy, and we moved forward. The invention
of the microscope opened up the small world of biology to us. In a broad sense,
science moves forward by inventing tools, because when you have those tools
they give you a new way of thinking.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“My initial reaction was shock—at both the ingenuity of the solution and the fact
that I’d forgotten all about it—but that quickly resolved into gratitude. I was
grateful to mayself for taking the time a year before to save me this time now.
‘Thank you, me-from-the-past!’ I literally said to myself.” <span class="citation">(Savage 2020)</span></p>
</blockquote>
<blockquote>
<p>“Complex equipment breaks, and when it breaks you need the technical expertise to
fix it, and you need replacement parts. … Some studies suggest that as much as 95
percent of medical technology donated to developing countries breaks within the
first five years of use.” <span class="citation">(Johnson 2011)</span></p>
</blockquote>
<blockquote>
<p>“Good ideas … are, inevitably, constrained by the parts and skills that surround
them. We have a natural tendance to romanticize breathrough innovations,
imagining momentous ideas transcending their surroundings, a gifted mind somehow
seeing over the detritus of old ideas and ossified tradition. But ideas are works
of bricolage; they’re built out of that detritus. We take the ideas we’ve inherited
or that we’ve stumbled across, and we jigger them together into some new shape.”
<span class="citation">(Johnson 2011)</span></p>
</blockquote>
<blockquote>
<p>“Good ideas are not conjured out of thin air; they are built out of a collection
of existing parts, the composition of which expands (and, occasionally, contracts)
over time. Some of these parts are conceptual: ways of solving problems, or new
definitions of what constitutes a problem in the first place. Some of them are,
literally, mechanical parts.” <span class="citation">(Johnson 2011)</span></p>
</blockquote>
<blockquote>
<p>“What kind of environment creates good ideas? The simplest way to answer is this:
innovative environments are better at helping their inhabitants explore the adjacent
possible, because they expose a wide and diverse sample of spare parts—mechanical
or conceptual—and they encourage novel ways of recombining those parts. Environments
that block or limit new combinations—by punishing experimentation, by obscuring
certain branches of possibility, by making the current state so satisfying that no
one bothers to explore the edges—will, on average, generate and circulate
fewer innovations that environments that encourage exploration.” <span class="citation">(Johnson 2011)</span></p>
</blockquote>
<blockquote>
<p>“Part of coming up with a good idea is discovering what those spare parts are, and
ensuring that you’re not just recycling the same old ingredients. … The trick to
having good ideas is not to sit around in glorious isolation and try to think big
thoughts. The trick is to get more parts on the table.” <span class="citation">(Johnson 2011)</span></p>
</blockquote>
<blockquote>
<p>“<em>Document the version of the software that you ran.</em> This may seem unimportant, but
remember the example from ‘Reproducible Research’ on page 6 where my colleagues and I
traced disagreeing results down to a single piece of software being updated. These
details matter. Good bioinformatices software usually has a command-line option to
return the current version. Software managed with a version control system such as
Git has explicit identifiers to every version, which can be used to document the
precise version you ran… If no version information is available, a release date,
link to the software, and download date will suffice.” <span class="citation">(Buffalo 2015)</span></p>
</blockquote>
<blockquote>
<p>“<em>Document when you downloaded data.</em> It’s important to include when the data was downloaded,
as the external data source (such as a website or server) might change in the future. For example,
a script that downloads data directly from a database might produce different results if
rerun after the external database is updated. Consequently, it’s important to document
when data came into your repository.” <span class="citation">(Buffalo 2015)</span></p>
</blockquote>
<blockquote>
<p>“All of this [documentation] information is best stored in plain-text README files.
Plain text can easily be read, searched, and edited directly from the command line,
making it the perfect choice for portable and accessible README files. It’s also available
on all computer systems, meaning you can document your steps when working directly on
a server or computer cluster. Plain text also lacks complex formatting, which can create
issues when copying and pasting commands from your documentation back into the command
line.” <span class="citation">(Buffalo 2015)</span></p>
</blockquote>

</div>
</div>
<p style="text-align: center;">
<a href="3.3-module13.html"><button class="btn btn-default">Previous</button></a>
<a href="3.5-module14.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
