## Using git and GitLab to implement version control

For many years, use of version control required use of the command line,
limiting its accessibility to researchers with limited programming experience.
However, graphical interfaces have removed this barrier, and RStudio has
particularly user-friendly tools for implementing version control. In this
module, we will show how to use *git* through RStudio's user-friendly
interface and how to connect from a local computer to *GitLab* through
RStudio.

**Objectives.** After this module, the trainee will be able to:

- Understand how to set up and use *git* through RStudio's interface 
- Understand how to connect with *GitLab* through RStudio to collaborate on  
research projects while maintaining version control

### Subsection 1

> "When the system prints the prompt `$` and you type commands that get 
executed, it's not the kernel that is talking to you, but a go-between called
the command interpreter or *shell*. The shell is just an ordinary program like
`date` or `who`, although it can do some remarkable things. The fact that the shell
sits between you and the facilities of the kernel has real benefits, some of which
we'll talk about here. There are three main ones: (1) Filename shorthands: you can 
pick up a whole set of filenames as arguments to a program by specifying a 
pattern for the names---the shell will find the filenames that fit your pattern; 
(2) Input-output redirection: you can arrange for the output of any program to 
go into a file instead of onto the terminal, and for the input to come from 
a file instead of the terminal. Input and output can even be connected to 
other programs. (3) Personalizing the environment: you can define your own 
commands and shorthands." [@kernighan1984unix]

> "Suppose you're typing a large document like a book. Logically this divides into many small pieces, 
like chapters and perhaps sections. Physically it should be divided too, because it is cumbersome
to edit large files. Thus you should type the document as a number of files. You might have separate
files for each chapter, called 'ch1', 'ch2', etc. ... With a systematic naming convention, you can tell at
a glance where a particular file fits into the whole. What if you want to print the whole book? You could 
say `$ pr ch1.1 ch1.2 ch 1.3 ...`, but you would soon get bored typing filenames and start to make mistakes.
This is where filename shorthand comes in. If you say `$ pr ch*` the shell takes the `*` to mean 'any
string of characters,' so ch* is a pattern that matches all filenames in the current directory that 
begin with ch. The shell creates the list, in alphabetical order, and passes the list to `pr`. The
`pr` command never sees the `*`; the pattern match that the shell does in the current directory 
generates aa list of strings that are passed to `pr`. The crucial point is that filename shorthand
is not a property of the `pr` command, but a service of the shell. Thus you can use it to generate
a sequence of filenames for *any* command." [@kernighan1984unix]

> "One of the virtues of the Unix system is that there are several ways to bring it closer to 
your personal taste or the conventions of your local computing environmentl. ... If there is a file
named '.profile' in your login directory, the shell will execute the commands in it when you log in,
before printing the first prompt. So you can put commands into '.profile' to set up your environment
as you like it, and they will be executed every time you log in. ...
Some of the properties of the shell are actually controlled by so-called *shell variables*, with 
values that you can access and set yourself. For example, the prompt string, which we have been showing
as `$`, is acually stored in a shell variable called 'PS1', and you can set it to anything you like, like
this `PS1='Yes dear?'`. ... Probably the most useful shell variable is the one that controls where the shell
looks for commands. Recall that when you type the name of a command, the shell normally looks for it 
first in the current directory, then in '/bin', and then in '/usr/bin'. This sequence of directories
is called the *search path*, and is stored in a shell variable called 'PATH'. If the default search 
path isn't what you want, you can change it, again usually in your '.profile'. ... It is also possible
to use variables for abbreviation. If you find yourself frequently referring to some directory with 
a long name, it might be worthwhile adding a line like `d=/horribly/long/directory/name` to your profile,
so that you can say things like `$cd $d`. Personal variables like `d` are conventionally spelled 
in lower case to distinguish them from those used by the shell itself, like `PATH`." [@kernighan1984unix]

> "The culmination of your login efforts is a *prompt*, usually a single character, indicating that the 
system is ready to accept commands from you. The prompt is most likely to be a dolloar sign or a percent
sign, but you can change it to anything you like... The prompt is actually printed by a program called
the *command interpreter* or *shell*, which is your main interface to the system. ... Once you receive 
the prompt, you can type *commands*, which are requests that the system do something. We will use *program*
as a synonym for command." [@kernighan1984unix]


> "While checksums are a great method to check if files are different, they don't tell
us *how* the files differ. One approach to this is to compute the *diff* between 
two files using the Unix tool *diff*. Unix's *diff* works line by line, and outputs
blocks (called *hunks*) that differ between files (resembling Git's *git diff* command)."
[@buffalo2015bioinformatics]


### Subsection 2

### Applied exercise
