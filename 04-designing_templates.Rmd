## Designing templates for "tidy" data collection

This module will move from the principles of the "tidy" data format to the
practical details of designing a "tidy" data format to use when collecting
experimental data. We will describe common issues that prevent biomedical
research datasets from being "tidy" and show how these issues can be avoided. We
will also provide rubrics and a checklist to help determine if a data collection
template complies with a "tidy" format.

**Objectives.** After this module, the trainee will be able to:

- Identify characteristics that keep a dataset from being 'tidy'
- Convert data from an "untidy" to a "tidy" format 

It is usually very little work to record data in a structure
that follows the "tidy data" principles, especially if you are planning to record
the data in a two-dimensional, tabular format already, and following these 
principles can bring some big advantages. We explain these rules and provide 
examples of biomedical datasets that both comply and don't comply with these
principles, to help make it clearer how you could structure a "tidy-compliant" 
structure for recording experimental data for your own research. 

If the data is the same regardless of whether it's "tidy" or not, then why all
the fuss about following the "tidy" principles when you're designing the format
you'll use to record your data? The magic here ix this---if you follow these
principles, then your data can be immediately input into a collection of
powerful tools for visualizing and analyzing the data, without further cleaning
steps (as discussed in the previous module). What's more, all those tools (the
set of tools is calld the "tidyverse") will typically *output* your data in a
"tidy" format, as well.

Once you have tools that input and output data in the same way, it becomes very 
easy to model each of the tools as "small, sharp tools"---each one does one 
thing, and does it really well. That's because, if each tool needs the same
type of input and creates that same type of output, those tools can be chained
together to solve complex problems. The alternative is to create large software
tools, ones that do a lot to the input data before giving you some output. 
"Big" tools are harder to understand, and more importantly, they make it hard
to adapt your own solutions, and to go beyond the analysis or visualization that
the original tool creators were thinking of when they created it. Think of it this
way---if you were writing an essay, how much more can you say when you can mix and 
match words to create your own sentences versus if you were made to combine 
pre-set sentences? 


### Subsection 1

> "Or maybe your goal is that your data is *usable* in a wide range of
applications? If so, consider adopting standard formats and metadata 
standards early on. At the very least, keep track of versions of data
and code, with associated dates." [@goodman2014ten]

> "Standards for data include, for example, data formats, data exchange
protocols, and meta-data controlled vocabularies." [@barga2011bioinformatics]

> "Software systems are transparent when they don't have murky corners or hidden
depths. Transparency is a passive quality. A program is passive when it is possible
to form a simple mental model of its behavior that is actuaally predictive for all
or most cases, because you can see through the machinery to what is actually going 
on." [@raymond2003art]

> "Software systems are discoverable when they include features that are designed 
to help you build in your mind a correct mental model of what they do and how they
work. So, for example, good documentation helps discoverability to a programmer. Discoverability
is an active quality. To achieve it in your software, you cannot merely fail to be obscure, 
you have to go out of your way to be helpful." [@raymond2003art]

> "Elegant code does much with little. Elegant code is not only correct but visibly, 
*transparently* correct. It does not merely communicate an algorithm to a computer, 
but also conveys insight and assurance to the mind of a human that reads it. By seeking
elegance in our code, we build better code. Learning to write transparent code is a first, 
long step toward learning how to write elegant code---and taking care to make code 
discoverable helps us learn how to make it transparent. Elegant code is both transparent and
discoverable." [@raymond2003art]

> "To design for transparency and discoverability, you need to apply every tactic for
keeping your code simple, and also concentrate on the ways in which your code is a 
communication to other human beings. The first questions to ask, after 'Will this design
work?' are 'Will it be reaadable to other people? Is it elegant?' We hope it is clear ...
that these questions are not fluff and that elegance is not a luxury. These qualities
in the human reaction to software are essential for reducing its bugginess and
increasing its long-term maintainability." [@raymond2003art]

> "Software is maintainable to the extent that people who are not its author can 
successfully understand and modify it. Maintainability demands more than code that
works; it demands code that follows the Rule of Clarity and communicates successfully 
to human beings as well as the computer." [@raymond2003art]

### Applied exercise


