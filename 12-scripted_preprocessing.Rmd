#  Experimental Data Preprocessing

## Principles and benefits of scripted pre-processing of experimental data

The experimental data collected for biomedical research often requires
pre-processing before it can be analyzed (e.g., gating of flow cytometry data,
feature finding / quantification for mass spectrometry data). Use of
point-and-click software can limit the transparency and reproducibility of this
analysis stage and is time-consuming for repeated tasks. We will explain how
scripted pre-processing, especially using open source software, can improve
transparency and reproducibility.

**Objectives.** After this module, the trainee will be able to:

- Define 'pre-processing' of experimental data 
- Describe an open source code script and explain how it can increase
reproducibility of data pre-processing

### What is pre-processing?

Some data collected through laboratory experiments is very straightforward and
requires little or no pre-processing before it's used in analysis. For example,
[example]. Other data may require some minimal pre-processing. For example, if
you plate bacteria from a sample at a variety of dilutions, you might count each
plate and determine a measure of Colony Forming Units from the set of plates
with different dilutions by deciding which dilution provides the clearest count
and then back-calculating based on its dilution to get the total number of
colony-forming units in the original sample.

This step of pre-processing data can become much more complex with data that was
collected using complex equipment, like a flow cytometer or a mass spectrometer.
In these cases, there are often steps required to extract from the machine's
readings a biologically-relevant measurement. For example, the data output from
a mass spectrometer must be processed to move from measurements of mass and
retention time to estimates of concentrations of different molecules in the
sample. If you want to compare across multiple samples, then the preprocessing
will also involve steps to align the different samples (in terms of ...), as
well as to standardize the measurements for each sample, to make the
measurements from the different samples comparable. For data collected from a
flow cytometer, preprocessing may include steps to disentangle the florescence
from different markers to ensure that the read for one marker isn't inflated by
spillover florescence from a different marker.

### Approaches to simple preprocessing tasks

There are several approaches for tackling this type of data preprocessing, to
get from the data that you initial observe (or that is measured by a piece of
laboratory equipment) to meaningful biological measurements that can be analyzed
and presented to inform explorations of a scientific hypothesis. While there are
a number of approaches that don't involve writing code scripts for this
preprocessing, there are some large advantages to scripting preprocessing any
time you are preprocessing experimental data prior to including it in figures or
further analysis. In this section, we'll describe some common non-scripted
approaches and discuss the advantages that would be brought by instead using a
code script. In the next module, we'll walk through an example of how scripts
for preprocessing can be created and applied in laboratory research.

In cases where the pre-processing is mathematically straightforward and the
dataset is relatively small, many researchers do the preprocessing by hand in a
laboratory notebook or through an equation or macro embedded in a spreadsheet.
For example, if you have plated samples at different dilutions and are trying to
calculate from these the CFUs in the original sample, this calculation is simple
enough that it could be done by hand. However, there are advantages to instead
writing a code script to do this simple preprocessing.

When you write a script to do a task with data, it is like writing a recipe that
can be applied again and again. By writing a script, you encode the process a
single time, so you can take the time to check and recheck to make sure that
you've encoded the process correctly. This helps in avoiding small errors when
you do the preprocessing---if you are punching numbers into a calculator over
and over, it's easy to mistype a number or forget a step every now and then,
while the code will ensure that the same process is run every time and that it
faithfully uses the numbers saved in the data for each step, rather than relying
on a person correctly entering each number in the calculation.

Scripts can be used across projects, as well, and so they can ensure consistency
in the calculation across projects. If different people do the calculation in
the lab for different projects or experiments, and they are doing the
calculations by hand, they might each do the calculation slightly differently,
even if it's only in small details like how they report rounded numbers. A
script will do the exact same thing every time it is applied. You can even share
your script with colleagues at other labs, if you want to ensure that your data
preprocessing is comparable for experiments conducted in different research
groups, and many scientific journals will allow supplemental material with 
code used for data preprocessing and analysis, or links within the manuscript
to a repository of this code posted online.

There are also gains in efficiency when you use a script. For small
pre-processing steps, these might seem small for each experiment, and certainly
when you first write the script, it will likely take longer to write and test
the script than it would to just do the calculation by hand (even more if
you're just starting to learn how to write code scripts). However, since the
script can be applied again and again, with very little extra work to apply it
to new data, you'll save yourself time in the future, and over a lot of
experiments and projects, this can add up. This makes it particularly useful to
write scripts for preprocessing tasks that you find yourself doing again and
again in the lab. 

### Approaches to more complex preprocessing tasks

Other preprocessing tasks can be much more complex, particularly those that need
to conduct a number of steps to extract biologically meaningful measurements
from the measurements made by a complex piece of laboratory equipment, as well
as steps to make sure these measurements can be meaningfully compared across
samples.

For these more complex tasks, the equipment manufacturer will often provide
software that can be used for the preprocessing. This software might conduct
some steps using defaults, and others based on the user's specifications. These
are often provided through "GUIs" (graphical user interfaces), where the user
does a series of point-and-click steps to process the data. In some software,
this series of point-and-click steps is recorded as the user does them, so that
these steps can be "re-run" later or on a different dataset. 

For many types of biological data, including output from equipment like flow
cytometers and mass spectrometers, open-source software has been developed
that can be used for this preprocessing. Often, the most cutting edge methods
for data preprocessing are first available through open-source software packages, 
if the methods are developed by researchers rather than by the companies, and
often many of the algorithms that are made available through the equipment
manufacturer's proprietary software are encoded versions of an algorithm 
first shared by researchers as open-source software. 

It can take a while to develop a code script for preprocessing the raw data from
a piece of complex equipment like a mass spectrometer. However, the process of
developing this script requires a thoughtful consideration of the steps of
preprocessing, and so this is often time well-spent. Again, this initial time
investment will pay off later, as the script can then be efficiently applied to
future data you collect from the equipment, saving you time in pointing and
clicking through the GUI software. Further, it's easier to teach someone else
how to conduct the preprocessing that you've done, and apply it to future 
experiments, because the script serves as a recipe. 

When you conduct data preprocessing in a script, this also gives you access to
all the other tools in the scripting language. For example, as you work through
preprocessing steps for a dataset, if you are doing it through an R script, you
can use any of the many visualization tools that are available through R. By
contrast, in GUI software, you are restricted to the visualization and other
tools included in that particular set of software, and those software developers
may not have thought of something that you'd like to do. Open-source scripting
languages like R, Python, and Julia include a huge variety of tools, and once
you have loaded your data in any of these platforms, you can use any of these
tools.

If you have developed a script for preprocessing your raw data, it also becomes
much easier to see how changes in choices in preprocessing might influence your
final results. It can be tricky to guess whether your final results are sensitive, 
for example, to what choice you make for a particular tranform for part of your
data, or in how you standardize data in one sample to make different samples 
easier to compare. If the preprocessing is in a script, then you can test making 
these changes and running all preprocessing and analysis scripts, to see if it 
makes a difference in the final conclusions. If it does, then it helps you 
identify parts of preprocessing that need to be deeply thought through for the 
type of data you're collecting, and you may want to explore the documentation on 
that particular step of preprocessing to determine what choice is best for your
data, rather than relying on defaults.
 
### Scripting preprocessing tasks

Code scripts can be developed for any open-source scripting languages, including
Python, R, and Julia. These can be embedded in or called from literate programming
documents, like RMarkdown and Julia, which are described in other modules. The 
word "script" is a good one here---it really is as if you are providing the script
for a play. In an interactive mode, you can send requests to run in the programming
language step by step using a console, while in a script you provide the whole list
of all of your "lines" in that conversation, and the programming language will run 
them all in order without you needing to interact from the console. 

For preprocessing the data, the script will have a few predictible parts. First,
you'll need to read the data in. There are different functions that can be used
to read in data from different file formats. For example, data that is stored in
an Excel spreadsheet can be loaded into R using functions in a package called
`readxl`. Data that is stored in a plain-text delimited format (like a csv file)
can be loaded into R using functions in the `readr` package.

When preprocessing data from complex equipment, you can determine how to read the
data into R by investigating the file type that is output by the equipment. 
Fortunately, many types of scientific equipment follow standardized file formats. 
This means that open-source developers can develop a single package that can 
load data from equipment from multiple manufacturers. For example, flow cytometry 
data is often stored in [file format]. Other biological datasets use file 
formats that are appropriate for very large datasets and that allow R to work 
with parts of the data at a time, without loading the full data in. [netCDF?]
In these cases, the first step in a script might not be to load in all the data, 
but rather to provide R with a connection to the larger datafile, so it can 
pull in data as it needs it. 

Once the data is loaded or linked in the script, the script can proceed through
steps required to preprocess this data. These steps will often depend on the type
of data, especially the methods and equipment used to collect it. For example, for
mass spectrometry data, these steps will include ... . For flow cytometry data, 
these steps would include ... . 

The functions for doing these steps will often come from extensions that
different researchers have made for R. Base R is a simpler collection of data
processing and statistics tools, but the open-source framework of R has allowed
users to make and share their own extensions. In R, these are often referred to
as "packages". Many of these are shared through the Comprehensive R Archive
Network (CRAN), and packages on CRAN can be directly installed using the
`install.packages` function in R, along with the package's names. While CRAN
is the common spot for sharing general-purpose packages, there is a specialized
repository that is used for many genomics and other biology-related R packages
called Bioconductor. These packages can also be easily installed through a call 
in R, but in this case it requires an installation function from the `BiocManager`
package. Many of the functions that are useful for preprocessing biological 
data from laboratory experiments are available through Bioconductor.

Table [x] includes some of the primary R packages on Bioconductor that can be
used in preprocessing different types of biological data. There are often
multiple choices, developed by different research groups, but this list provides
a starting point of several of the standard choices that you may want to
consider as you start developing code.

Much of the initial preprocessing might use very specific functions that are
tailored to the format that the data takes once it is loaded. Later in the
script, there will often be a transfer to using more general-purpose tools in
that coding language. For example, once data is stored in a "dataframe" format
in R, it can be processed using a powerful set of general purpose tools
collected in a suite of packages called the "tidyverse". This set of packages
includes functions for filtering to specific subsets of the data, merging
separate datasets, adding new measurements for each observation that are
functions of the initial measurements, summarizing, and visualizing. The
tidyverse suite of R tools is very popular in general R use and is widely
taught, including through numerous free online resources. By moving from
specific tools to these more general tools as soon as possible in the script, a
researcher can focus his or her time in learning these general purpose tools
well, as these can be widely applied across many types of data.

By the end of the script, data will be in a format that has extracted
biologically relevant measurements. Ideally, this data will be in a general
purpose format, like a dataframe, to make it easier to work with using general
purpose tools in the scripting language when the data is used in further data
analysis or to create figures for reports, papers, and presentations. Often, you 
will want to save a version of this preprocessed version of the data in your 
project files, and so the last step of the script might be to write out the 
cleaned data in a file that can be loaded in later scripts for analysis and 
visualization. This is especially useful if these data preprocessing steps are 
time consuming, as is often the case for the large raw datasets output by 
laboratory equipment like flow cytometers and mass spectrometers.

Figure [x] gives an example of a data preprocessing script, highlighting these
different common areas that often show up in these scripts.

[Some data may be incorporated into the preprocessing by downloading it from 
databases or other online sources. These data downloads can be automated and 
recorded by using scripted code for the download in many cases, as long as the 
database or online source offers web services or another API for this type of
scripted data access. In this case, you can incorporate the script in a 
RMarkdown document to record the date the data was downloaded, as well as the
code used to download it. R is able to run system calls, and one of these
will provide the current date, so this can be included in an RMarkdown file
to record the date the file is run. Further, there may be a call that can 
be made to the online data source's API that returns the working version of 
the database or source, and if so this can also be included in the RMarkdown
code used to access the data.]

RMarkdown files can be used to combine both code and more manual document
(for example, a record of which collaborator provided each type of data file).
While traditionally this more manual documentation was recommended to be 
recorded in plain-text README files in a project's directory and subdirectories
[@buffalo2015bioinformatics], RMarkdown files provide some advantages over
this traditional approach. First, RMarkdown files are themselves in plain
text, and so they offer the advantages of simple plain text documentation 
files (e.g., ones never rendered to another format) in terms of being able
to use script-based tools to search them. Further, they can be rendered into
attractive formatted documents that may be easier to share with project
team members who do not code. 

[Example of a function: recipe for making a vinaigrette. There will be a 
"basic" way that the function can run, which uses its default parameters. 
However, you can also specify and customize certain inputs (for example, 
using walnut oil instead of olive oil, or adding mustard) to tweak the 
recipe in slight ways each time you use it, and to get customized outputs.]

[History of the mouse---enable GUIs, before everything was from the terminal.]

### Potential quotes

> For bioinformatics, "all too often the software is developed without
thought toward future interoperability with other software products. As a 
result, the bioinformatics software landscape is currently characterized
by fragmentation and silos, in which each research group develops and uses
only the tools created within their lab." [@barga2011bioinformatics]

> "The group also noted the lack of agility. Although they may be aware of
a new or better algorithm they cannot easily integrate it into their 
analysis pipelines given the lack of standards across both data formats
and tools. It typically requires a complete rewrite of the code in order
to take advntge of a new technique or algorithm, requiring time and often
funding to hire developers." [@barga2011bioinformatics]

> "The benefit of working with a programming language is that you have the code in
a file. This means that you can easily reuse that code. If the code has
parameters it can even be applied to problems that follow a similar pattern."
[@janssens2014data]

> "Data exploration in spreadsheet software is typically conducted via menus and
dialog boxes, which leaves no record of the steps taken." [@murrell2009introduction]

> "One reason Unix developers have been cool toward GUI interfaces is that, in their
designers' haste to make them 'user-friendly' each one often becomes frustratingly 
opaque to anyone who has to solve user problems---or, indeed, interact with it anywhere
outside the narrow range predicted by the user-interface designer." [@raymond2003art]

> "Many operating systems touted as more 'modern' or 'user friendly' than Unix achieve their
surface glossiness by locking users and developers into one interface policy, and offer an
application-programming interface that for all its elaborateness is rather narrow and rigid. 
On such systems, tasks the designers have anticipated are very easy---but tasks they have
not anticipated are often impossible or at best extremely painful. Unix, on the other hand, has
flexibility in depth. The many ways Unix provides to glue together programs means that components
of its basic toolkit can be combined to produce useful effects that the designers of the individual
toolkit parts never anticipated." [@raymond2003art]

> "The good news is that a computer is a general-purpose machine, capable of performing 
any computation. Although it only has a few kinds of instructions to work with, it can 
do them blazingly fast, and it can largely control its own operation. The bad news is 
that it doesn't do anything itself unless someone tells it what to do, in excruciating
detail. A computer is the ultimate sorcere's apprentice, able to follow instructions
tirelessly and without error, but requiring painstaking accuracy in the 
specification of what to do." [@kernighan2011d]

> "*Software* is the general term for sequences of instructions that make a computer
do something useful. It's 'soft' in contrast with 'hard' hardware, because it's 
intangible, not easy to put your hands on. Hardware is quite tangible: if you drop
a computer on your foot, you'll notice. Not true for software." [@kernighan2011d]

> "Modern system increasingly use general purpose hardware---a processor, some memory, 
and connections to the environment---and create specific behaviors by software. The
conventional wisdom is that software is cheaper, more flexible, and easier to change than
hardware is (especially once some device has left the factory)." [@kernighan2011d]

> "An algorithm is a precise and unambiguous recipe. It's expressed in terms of a fixed 
set of basic operations whose meanings are completely known and specified; it spells out
a sequence of steps using those operations, with all possible situations covered; it's 
guaranteed to stop eventually. On the other hand, a *program* is the opposite of 
abstract---it's a concrete statement of the steps that a real computer must perform to 
accomplish a task. The distinction between an algorithm and a program is like the difference
between a blueprint and a building; one is an idealization and the other is the real thing."
[@kernighan2011d]

> "One way to view a program is as one or more algorithms expressed in a form that a computer
can process directly. A program has to worry about practical problems like inadequate memory, 
limited processor speed, invalid and even malicious input data, faulty hardware, broken 
network connections, and (in the background and often exacerbating the other problems)
human frailty. So if an algorithm is an idealized recipe, a program is the instructions for 
a cooking robot preparing a month of meals for an army while under enemy attack." [@kernighan2011d]

> "During the late 1950s and early 1960s, another step was taken towards getting the 
computer to do more for programmers, arguably the most important step in the history of 
programming. This was the development of 'high-level' programming languages that were
independent of any particular CPU architecture. High-level languages make it possible to 
express computations in terms that are closer to the way a person might express them." 
[@kernighan2011d]

> "Programming in the real world tends to happen on a large scale. The strategy is similar
to what one might use to write a book or undertake any other big project: figure out what
to do, starting with a broad specification that is broken into smaller and smaller pieces, 
then work on the pieces separately, while making sure that they hang together. In programming, 
pieces tend to be of a size such that one person can write the precise computational steps
in some programming language. Ensuring that the pieces written by different programmers
work together is challenging, and failing to get this right is a major source of errors. 
For instance, NASA's Mars Climate Orbiter failed in 1999 because the flight system software
used metric units for thrust, but course correction data was entered in English units, 
causing an erroneous trajectory that brought the Orbiter too close to the planet's 
surface." [@kernighan2011d]

> "If you're going to build a house today, you don't start by cutting down trees to make 
lumber and digging clay to make your own bricks. Instead, you buy prefabricated pieces like
doors, windows, plumbing fixtures, a furnace, and a water heater. House construction is still
a big job, but it's manageable because you can build on the work of many others and rely 
on an infrastructure, indeed an entire industry, that will help. The same is true of 
programming. Hardly any significant program is created from nothing. Many components written
by others can be taken off the shelf and used. For instance, if you're writing a program for
Windows or a Mac, there are libraries of prefabricated menus, buttons, text editors, graphics, 
network connections, database access, and so on. Much of the job is understanding the components
and gluing them together in your own way. Of course, many of these components in turn rest on
other simpler and more basic ones, often for several layers. Below that, everything runs on 
the operating system, a program that manages the hardware and controls everything that happens."
[@kernighan2011d]

> "At the simplest level, programming languages provide a mechanism called functions that make
it possible for one programmer to write code that performs a useful a useful task, then package
it in a form that other programmers can use in their programs without having to know how it 
works." [@kernighan2011d]

> "A function has a name and a set of input data values that it needs to do its job; it does 
a computation and returns a result to the part of the program that called it. ... Functions
make it possible to create a program by building on components that have been created separately
and can be used as necessary by all programmers. A collection of related functions is usually 
called a *library*. ... The services that a function library provides are described to programmers
in terms of an *Application Programming Interface*, or *API*, which lists the functions, what
they do, how to use them in a program, what input data they require, and what values they 
produce. The API might also describe data structures---the organization of data that is passed
back and forth---and various other bits and pieces that all together define what a programmer
has to do to request services and what will be computed as a result. This specification must
be detailed and precise, since in the end the program will be interpreted by a dumb literal 
computer, not by a friendly and accomodating human." [@kernighan2011d]

> "The code that a programmer writes, whether in assembly language or (much more likely) in 
a high-level language, is called *source code*. ... Source code is readable by other programmers, 
though perhaps with some effort, so it can be studied and adapted, and any innovations or ideas
it contains are visible." [@kernighan2011d]

> "In early times, most software was developed by companies and most source code was 
unavailable, a trade secret of whoever developed it." [@kernighan2011d]

> "An *operating system* is the software underpinning that manages the hardware of a 
computer and makes it possible to run other programs, which are called *applications*.
... It's a clumsy but standard terminology for programs that are more or less self-contained
and focused on a single task." [@kernighan2011d]

> "Software, like many other things in computing, is organized into layers, analogous to 
geological strata, that separate one concern from another. Layering is one of the important
ideas that help programmers to manage complexity." [@kernighan2011d]

> "I think that it's important for a well-informed person to know something about 
programming, perhaps only that it can be surprisingly difficult to get very simple
programs working properly. There is nothing like doing battle with a computer to teach 
this lesson, but also to give people a taste of the wonderful feeling of accomplishment
when a program does work for the first time. It may also be valuable to have enough 
programming experience that you are cautious when someone says that programming is easy, 
or that there are no errors in a program. If you have trouble making 10 lines of code 
work after a day of struggle, you might be legitimately skeptical of someone who claims
that a million-line program will be delivered on time and bug-free." [@kernighan2011d]

> "Programming languages share certain basic ideas, since they are all notations for spelling
out a computation as a sequence of steps. Every programming language thus will provide ways
to get input data upon which to compute; do arithmetic; store and retrieve intermediate 
values as computation proceeds; display results along the way; decide how to proceed on the basis 
of previous computations; and save results when the computation is finished. Languages have
*syntax*, that is, rules that define what is grammatically legal and what is not. 
Programming languages are picky on the grammatical side: you have to say it right or there
will be a complaint. Languages also have *semantics*, that is, a defined meaning for every 
construction in the language." [@kernighan2011d]

> "In programming, a *library* is a collection of related pieces of code. A library typically 
includes the code in compiled form, along with needed source code declarations [for C++]. 
Libraries can include stand-alone functions, classes, type declarations, or anything else that
can appear in code." [@spraul2012think]

> "One way to write R code is simply to enter it interactively at the command line... This 
interactivity is beneficial for experimenting with R or for exploring a data set in a casual
manner. ... However, interactively typing code at the R command line is a very bad approach from 
the perspective of recording and documenting code because the code is lost when R is shut down. 
A superior approach in general is to write R code in a file and get R to read the code from the file." [@murrell2009introduction]

> "The features of R are organized into separate bundles called *packages*. The standard R 
installation includes about 25 of those packages, but many more can be downloaded from CRAN and
installed to expand the things that R can do. ... Once a package is installed, it must be 
*loaded* within an R session to make the extra features available. ... Of the 25 packages
that are installed by default, nine packages are *loaded* by default when we start a new
R session; these provide the basic functionality of R. All other packages must be loaded
before the relevant features can be used." [@murrell2009introduction]

> "The R environment is the software used to run R code." [@murrell2009introduction]

> "*Document your methods and workflows.* This should include full command lines (copied
and pasted) that are run through the shell that generate data or intermediate results. 
Even if you use the default values in software, be sure to write these values down; 
later versions of the program may use different default values. Scripts naturally 
document all steps and parameters ..., but be sure to document any command-line options
used to run this script. In general, any command that produces results in your work needs
to be documented somewhere." [@buffalo2015bioinformatics]

> "*Document the version of the software that you ran.* This may seem unimportant, but
remember the example from 'Reproducible Research' on page 6 where my colleagues and I 
traced disagreeing results down to a single piece of software being updated. These 
details matter. Good bioinformatices software usually has a command-line option to 
return the current version. Software managed with a version control system such as 
Git has explicit identifiers to every version, which can be used to document the 
precise version you ran... If no version information is available, a release date, 
link to the software, and download date will suffice." [@buffalo2015bioinformatics]

> "*Document when you downloaded data.* It's important to include when the data was downloaded, 
as the external data source (such as a website or server) might change in the future. For example, 
a script that downloads data directly from a database might produce different results if 
rerun after the external database is updated. Consequently, it's important to document
when data came into your repository." [@buffalo2015bioinformatics]

> "All of this [documentation] information is best stored in plain-text README files.
Plain text can easily be read, searched, and edited directly from the command line, 
making it the perfect choice for portable and accessible README files. It's also available
on all computer systems, meaning you can document your steps when working directly on 
a server or computer cluster. Plain text also lacks complex formatting, which can create
issues when copying and pasting commands from your documentation back into the command 
line." [@buffalo2015bioinformatics]

> "The computer is a very flexible and powerful tool, and it is a tool that is ours
to control. Files and documents, especially those in open standard formats, can be 
manipulated using a variety of software tools, not just one specific piece of software.
A programming lanuage is a tool that allows us to manipulate data stored in files and
to manipulate data held in RAM in unlimited ways. Even with a basic knowledge of 
programming, we can perform a huge variety of data processing tasks." [@murrell2009introduction]

> "Computer code is the preferred approach to communicating our instructions to the 
computer. The approach allows us to be precise and expressive, it provides a complete
record of our actions, and it allows others to replicate our work." [@murrell2009introduction]

> "Programming in R is carried out, primarily, by manipulating and modifying data structures.
These different transformations are carried out using functions and operators. In R, 
virtually every operation is a function call, and though we separate our discussion into
operators and function calls, the distinction is not strong ... The R evaluator and
many functions are written in C but most R functions are written in R itself." 
[@gentleman2008r]

> "Many biologists are first exposed to the R language by following a cookbook-type
approach to conduct a statistical analysis like a t-test or an analysis of 
variance (ANOVA). ALthough R excels at these and more complicated statistical 
tests, R's real power is as a data programming lanugage you can use to explore and
understand data in an open-ended, highly interactive, iterative way. Learning R as a 
data programming language will give you the freedom to experiment and problem solve
during data analysis---exactly what we need as bioinformaticians." [@buffalo2015bioinformatics]

> "Popularized by statistician John W. Tukey, EDA is an approach that emphasizes 
understanding data (and its limitations) through interactive investigation
rather than explicit statitical modeling. In his 1977 book *Exploratory Data
Analysis*, Tukey described EDA as 'detective work' involved in 'finding and 
revealing the clues' in data. As Tukey's quote emphasizes, EDA is much more an approach
to exploring data than using specific statistical methods. In the face of rapidly 
changing sequencing technologies, bioinformatics software, and statistical methods, 
EDA skills are not only widely applicable and comparatively stable---they're also 
essential to making sure that our analyses are robust to these new data and methods."
[@buffalo2015bioinformatics]

> "Developing code in R is a back-and-forth between writing code in a rerunnable script
and exploring data interactively in the R interpreter. To be reproducible, all steps 
that lead to results you'll use later must be recorded in the R script that accompanies
your analysis and interactive work. While R can save a history of the commands you've
entered in the interpreter during a session (with the command `savehistory()`), 
storing your steps in a well-commented R script makes your life much easier when you 
need to backtrack to understand what you did or change your analysis." [@buffalo2015bioinformatics]

> "It's a good idea to avoid referring to specific dataframe rows in your analysis code. 
This would produce code fragile to row permutations or new rows that may be generated
by rerunning a previous analysis step. In every case in which you might need to refer
to a specific row, it's avoidable by using subsetting... Similarly, it's a good idea
to refer to columns by their column name, *not* their position. While columns may be 
less likely to change across dataset versions than rows, it still happens. Column names
are more specific than positions, and also lead to more readable code."
[@buffalo2015bioinformatics]

> "In bioinformatics, we often need to extract data from strings. R has several 
functions to manipulate strings that are handy when working with bioinformatics data in 
R. Note, however, that for most bioinformatics text-processing tasks, R is *not*
the preferred language to use for a few reasons. First, R works with all data stored
in memory; many bioinformatics text-processing tasks are best tackled with the 
stream-based approaches..., which explicityly avoid loading all data in memory at
once. Second, R's string processing functions are admittedly a bit clunky compared 
to Python's." [@buffalo2015bioinformatics]

> "Versions fo R and any R pakcages installed change over time. This can lead to 
reproducibility headaches, as the results of your analyses may change with the
changing version of R and R packages. ... you should always record the versions
of R and any packages you use for analysis. R actually makes this incrediably 
easy to do---just call the `sessionInfo()` function." [@buffalo2015bioinformatics]

> "Bioconductor is an open source R software project focused on developing tools
for high-throughput genomics and molecular biology data." [@buffalo2015bioinformatics]

> "Bioconductor's pakcage system is a bit different than those on the Comprehensive R 
Archive Network (CRAN). Bioconductor packages are released on a set schedule, twice 
a year. Each release is coordinated with a version of R, making Bioconductor's versions
tied to specific R versions. The motivation behind this strict coordination is that it 
allows for packages to be thoroughly tested before being released for public use. 
Additionally, because there's considerable code re-use within the Bioconductor project, 
this ensures that all package versions within a Bioconductor release are compatible
with one another. For users, the end result is that packages work as expected and 
have been rigorously tested before you use it (this is good when your scientific
results depend on software reliability!). If you need the cutting-edge version of a 
package for some reason, it's always possible to work with their development branch."
[@buffalo2015bioinformatics]

> "When installing Bioconductor packages, we use the `biocLite()` function. `biocLite()`
installs the correct version of a package for your R version (and its corresponding
Bioconductor version)." [@buffalo2015bioinformatics]

> "In addition to a careful release cycle that fosters package stability, Bioconductor
also has extensive, excellent documentation. The best, most up-to-date documentation
for each package will always be a Bioconductor [web address]. Each package has a full 
reference manual covering all functions and classes included in a package, 
as well as one or more in-depth vignettes. Vignettes step through many examples and 
common workflows using packages." [@buffalo2015bioinformatics]

> "Quite often, users don’t appreciate the opportunities. Noncomputational
biologists don’t know when to complain about the status quo. With modest amounts
of computational consulting, long or impossible jobs can become much shorter or
richer." --- Barry Demchak in [@altschul2013anatomy]

> "People not doing the computational work tend to think that you can write a
program very fast. That, I think, is frankly not true. It takes a lot of time to
implement a prototype. Then it actually takes a lot of time to really make it
better." --- Heng Li in [@altschul2013anatomy]

> "There is also a problem with discovering software that exists; often people
reinvent the wheel just because they don’t know any better. Good repositories
for software and best practice workflows, especially if citable, would be a
start." --- James Taylor in [@altschul2013anatomy]

> " Now there are a lot of strong, young, faculty members who label themselves
as computational analysts, yet very often want wet-lab space. They're not
content just working off data sets that come from other people. They want to be
involved in data generation and experimental design and mainstreaming
computation as a valid research tool. Just as the boundaries of biochemistry and
cell biology have kind of blurred, I think the same will be true of
computational biology. It’s going to be alongside biochemistry, or molecular
biology or microscopy as a core component." --- Richard Durbin in
[@altschul2013anatomy]

> "I would say that computation is now as important to biology as chemistry is.
Both are useful background knowledge. Data manipulation and use of information
are part of the technology of biology research now. Knowing how to program also
gives people some idea about what's going on inside data analysis. It helps them
appreciate what they can and can't expect from data analysis software." ---
Richard Durbin in [@altschul2013anatomy]

> "**Does every new biology PhD student need to learn how to program?** To some,
the answer might be “no” because that’s left to the experts, to the people
downstairs who sit in front of a computer. But a similar question would be: does
every graduate student in biology need to learn grammar? Clearly, yes. Do they
all need to learn to speak? Clearly, yes. We just don't leave it to the
literature experts. That’s because we need to communicate. Do students need to
tie their shoes? Yes. It has now come to the point where using a computer is as
essential as brushing your teeth. If you want some kind of a competitive edge,
you’re going to want to make as much use of that computer as you can. The
complexity of the task at hand will mean that canned solutions don’t exist. It
means that if you’re using a canned solution, you’re not at the edge of
research." --- Martin Krzywinski in [@altschul2013anatomy]


### Discussion questions

